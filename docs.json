[
  {
    "tags": [],
    "description": {
      "full": "<p><code>telemetry.js</code> is the API for interfacing data aggregated for telemetry<br />dashboard. As of writing it mainly offers access to:</p>\n\n<ul>\n<li>Evolution of histograms over builds and time, and</li>\n<li>Evolution of simple measures over build and time (as histograms)</li>\n</ul>\n\n<p>The goal for <code>telemetry.js</code> is to offer a stable, well documented, easy to<br />use, interface for aggregated telemetry data. So that anybody can access the<br />raw aggregates with the aim of developing and deploying custom dashboards.</p>\n\n<h3>Quick Start <code>telemetry.js</code></h3>\n\n<p><em>For a really quick start there is a demo on<br /><a href=\"http://jsfiddle.net/mkXLg/\">jsfiddle</a>.</em></p>\n\n<ol>\n<li>Include <code><a href='http://telemetry.mozilla.org/v1/telemetry.js'>http://telemetry.mozilla.org/v1/telemetry.js</a></code>, you <strong>must</strong>\ninclude from here, <strong>don't host it yourself</strong>.</li>\n<li>Optionally, include <code><a href='http://telemetry.mozilla.org/v1/big.js'>http://telemetry.mozilla.org/v1/big.js</a></code>,\n<a href=\"https://github.com/MikeMcl/big.js/\">big.js</a> is only needed for some\nfeatures.</li>\n<li>Initialize <code>telemetry.js</code> with <code>Telemetry.init(callback)</code></li>\n<li>Choose <code>'&lt;channel&gt;/&lt;version&gt;'</code> string from <code>Telemetry.versions()</code></li>\n<li>Load measures for version with <code>Telemetry.measures(version, callback)</code></li>\n<li>Load evolution of histogram for choice of version and measure with\n<code>Telemetry.loadEvolutionOverBuilds(version, measure, callback)</code></li>\n<li>Iterate over histograms and dates, filter histograms, display results.</li>\n</ol>\n\n<p><strong>Step 3 through 7</strong> are illustrated below</p>\n\n<pre><code>// First initialize telemetry.js (this loads some meta-data from server)\nTelemetry.init(function() {\n  // Telemetry is now loaded an ready for use, we now get a list of\n  // '&lt;channel&gt;/&lt;version&gt;' strings\n  var versions = Telemetry.versions();\n\n  // We then pick a version, in this the first\n  var version = versions[0];\n\n  // Then we load measures available for the given version\n  Telemetry.measures(version, function(measures) {\n    // In this callback `measures` is now a JSON object on the form:\n    // {MEASURE_ID: {kind: \"linear\", description: \"...\"}, ...}\n    // Let's choose a measure id, say 'CYCLE_COLLECTOR' if available\n    var measure = 'CYCLE_COLLECTOR';\n    if (measures['CYCLE_COLLECTOR'] === undefined) {\n      // If 'CYCLE_COLLECTOR' isn't available we just pick any other\n      // measure, say the first in the list of keys on the JSON object\n      measure = Object.keys(measures)[0];\n    }\n\n    // We then load evolution of this measure over build dates\n    Telemetry.loadEvolutionOverBuilds(version, measure,\n                                      function(histogramEvolution) {\n      // The HistogramEvolution instance holds a set of dates and\n      // histograms, we can iterate over them as follows\n      histogramEvolution.each(function(date, histogram) {\n        // First let's log the date of the histogram, in this case we\n        // have a build date and number of submissions\n        console.log(\"For builds on \" + date.toString() + \" we have\");\n        console.log(histogram.submissions() + \"submissions and\");\n\n        // We can also iterate over buckets in the histogram, map is\n        // just a convenient adaption of Javascripts `Array.map`\n        console.log(histogram.map(function(count, start, end, index) {\n          return count + \" hits between \" + start + \" and \" + end;\n        }).join('\\n'));\n      });\n    });\n  });\n});\n</code></pre>\n\n<h3>Deployment and API Stability</h3>\n\n<p>It is the <strong>intend</strong> that the APIs documented here should remain stable.<br />And going forward consumers of telemetry dashboard data should be comfortable<br />including <code>telemetry.js</code> from:</p>\n\n<ul>\n<li><code><a href='http://telemetry.mozilla.org/v1/telemetry.js'>http://telemetry.mozilla.org/v1/telemetry.js</a></code></li>\n</ul>\n\n<p>As <code>telemetry.js</code> separates data access from data storage layout, this will<br />enable telemetry-dashboard developers to change data storage layout as well<br />as adding features to <code>telemetry.js</code> without breaking custom dashboards<br />deployed in the wild.</p>\n\n<p>Again, there is no guarantee that all functions in <code>telemetry.js</code> will<br />continue to work exactly like they do now, this isn't a Mars rover project,<br />this is a promised of best efforts. If it should ever become desired to<br />refactor <code>telemetry.js</code> there will probably be implemented a shim that<br />exposes the old API and host at <code>telemetry.mozilla.org/v1/telemetry.js</code>.</p>\n\n<p><strong>Warning</strong> <code>telemetry.js</code> does include URLs point to data on the server,<br />these URLs will be subject to change <strong>without warning</strong>. So you should<br />never included <code>telemetry.js</code> form any where other than the official URL<br />noted below.</p>\n\n<ul>\n<li><code><a href='http://telemetry.mozilla.org/v1/telemetry.js'>http://telemetry.mozilla.org/v1/telemetry.js</a></code></li>\n</ul>\n\n<p>If you distribute your own version of <code>telemetry.js</code> or access the raw data<br />around <code>telemetry.js</code> you should expect your code to break at anytime.<br />The only supported way to consume telemetry dashboard data is through<br /><code>telemetry.js</code> included from the source directed above.</p>\n\n<h3>Auxiliary Libraries</h3>\n\n<p>The drop-down selectors used on the <a href=\"telemetry.mozilla.org\">dashboard</a> are<br />fairly non-trivial to implement. Luckily, they are provided as an individual<br />component in <code>jquery.telemetry.js</code>, this requires the jQuery UI widget<br />factory, which can be found in <code>jquery.ui.widget.js</code>. You may also optionally<br />use <code>bootstrap-selector.js</code> with<br /><a href=\"http://silviomoreto.github.io/bootstrap-select/\">bootstrap-select</a> to get<br />pretty <a href=\"http://getbootstrap.com/\">twitter-bootstrap</a> selectors.</p>\n\n<p>Take a look at the sources for telemetry-dashboard to see how<br /><code>jquery.telemetry.js</code> works, it's also fairly well documented in source. To<br />use these files hot-linking is, however, not recommended. Distribute them on<br />your own and update them as the dashboard gets updated. It's only<br /><code>telemetry.js</code> that should be included from <code>telemetry.mozilla.org</code>.</p>",
      "summary": "<p><code>telemetry.js</code> is the API for interfacing data aggregated for telemetry<br />dashboard. As of writing it mainly offers access to:</p>",
      "body": "<ul>\n<li>Evolution of histograms over builds and time, and</li>\n<li>Evolution of simple measures over build and time (as histograms)</li>\n</ul>\n\n<p>The goal for <code>telemetry.js</code> is to offer a stable, well documented, easy to<br />use, interface for aggregated telemetry data. So that anybody can access the<br />raw aggregates with the aim of developing and deploying custom dashboards.</p>\n\n<h3>Quick Start <code>telemetry.js</code></h3>\n\n<p><em>For a really quick start there is a demo on<br /><a href=\"http://jsfiddle.net/mkXLg/\">jsfiddle</a>.</em></p>\n\n<ol>\n<li>Include <code><a href='http://telemetry.mozilla.org/v1/telemetry.js'>http://telemetry.mozilla.org/v1/telemetry.js</a></code>, you <strong>must</strong>\ninclude from here, <strong>don't host it yourself</strong>.</li>\n<li>Optionally, include <code><a href='http://telemetry.mozilla.org/v1/big.js'>http://telemetry.mozilla.org/v1/big.js</a></code>,\n<a href=\"https://github.com/MikeMcl/big.js/\">big.js</a> is only needed for some\nfeatures.</li>\n<li>Initialize <code>telemetry.js</code> with <code>Telemetry.init(callback)</code></li>\n<li>Choose <code>'&lt;channel&gt;/&lt;version&gt;'</code> string from <code>Telemetry.versions()</code></li>\n<li>Load measures for version with <code>Telemetry.measures(version, callback)</code></li>\n<li>Load evolution of histogram for choice of version and measure with\n<code>Telemetry.loadEvolutionOverBuilds(version, measure, callback)</code></li>\n<li>Iterate over histograms and dates, filter histograms, display results.</li>\n</ol>\n\n<p><strong>Step 3 through 7</strong> are illustrated below</p>\n\n<pre><code>// First initialize telemetry.js (this loads some meta-data from server)\nTelemetry.init(function() {\n  // Telemetry is now loaded an ready for use, we now get a list of\n  // '&lt;channel&gt;/&lt;version&gt;' strings\n  var versions = Telemetry.versions();\n\n  // We then pick a version, in this the first\n  var version = versions[0];\n\n  // Then we load measures available for the given version\n  Telemetry.measures(version, function(measures) {\n    // In this callback `measures` is now a JSON object on the form:\n    // {MEASURE_ID: {kind: \"linear\", description: \"...\"}, ...}\n    // Let's choose a measure id, say 'CYCLE_COLLECTOR' if available\n    var measure = 'CYCLE_COLLECTOR';\n    if (measures['CYCLE_COLLECTOR'] === undefined) {\n      // If 'CYCLE_COLLECTOR' isn't available we just pick any other\n      // measure, say the first in the list of keys on the JSON object\n      measure = Object.keys(measures)[0];\n    }\n\n    // We then load evolution of this measure over build dates\n    Telemetry.loadEvolutionOverBuilds(version, measure,\n                                      function(histogramEvolution) {\n      // The HistogramEvolution instance holds a set of dates and\n      // histograms, we can iterate over them as follows\n      histogramEvolution.each(function(date, histogram) {\n        // First let's log the date of the histogram, in this case we\n        // have a build date and number of submissions\n        console.log(\"For builds on \" + date.toString() + \" we have\");\n        console.log(histogram.submissions() + \"submissions and\");\n\n        // We can also iterate over buckets in the histogram, map is\n        // just a convenient adaption of Javascripts `Array.map`\n        console.log(histogram.map(function(count, start, end, index) {\n          return count + \" hits between \" + start + \" and \" + end;\n        }).join('\\n'));\n      });\n    });\n  });\n});\n</code></pre>\n\n<h3>Deployment and API Stability</h3>\n\n<p>It is the <strong>intend</strong> that the APIs documented here should remain stable.<br />And going forward consumers of telemetry dashboard data should be comfortable<br />including <code>telemetry.js</code> from:</p>\n\n<ul>\n<li><code><a href='http://telemetry.mozilla.org/v1/telemetry.js'>http://telemetry.mozilla.org/v1/telemetry.js</a></code></li>\n</ul>\n\n<p>As <code>telemetry.js</code> separates data access from data storage layout, this will<br />enable telemetry-dashboard developers to change data storage layout as well<br />as adding features to <code>telemetry.js</code> without breaking custom dashboards<br />deployed in the wild.</p>\n\n<p>Again, there is no guarantee that all functions in <code>telemetry.js</code> will<br />continue to work exactly like they do now, this isn't a Mars rover project,<br />this is a promised of best efforts. If it should ever become desired to<br />refactor <code>telemetry.js</code> there will probably be implemented a shim that<br />exposes the old API and host at <code>telemetry.mozilla.org/v1/telemetry.js</code>.</p>\n\n<p><strong>Warning</strong> <code>telemetry.js</code> does include URLs point to data on the server,<br />these URLs will be subject to change <strong>without warning</strong>. So you should<br />never included <code>telemetry.js</code> form any where other than the official URL<br />noted below.</p>\n\n<ul>\n<li><code><a href='http://telemetry.mozilla.org/v1/telemetry.js'>http://telemetry.mozilla.org/v1/telemetry.js</a></code></li>\n</ul>\n\n<p>If you distribute your own version of <code>telemetry.js</code> or access the raw data<br />around <code>telemetry.js</code> you should expect your code to break at anytime.<br />The only supported way to consume telemetry dashboard data is through<br /><code>telemetry.js</code> included from the source directed above.</p>\n\n<h3>Auxiliary Libraries</h3>\n\n<p>The drop-down selectors used on the <a href=\"telemetry.mozilla.org\">dashboard</a> are<br />fairly non-trivial to implement. Luckily, they are provided as an individual<br />component in <code>jquery.telemetry.js</code>, this requires the jQuery UI widget<br />factory, which can be found in <code>jquery.ui.widget.js</code>. You may also optionally<br />use <code>bootstrap-selector.js</code> with<br /><a href=\"http://silviomoreto.github.io/bootstrap-select/\">bootstrap-select</a> to get<br />pretty <a href=\"http://getbootstrap.com/\">twitter-bootstrap</a> selectors.</p>\n\n<p>Take a look at the sources for telemetry-dashboard to see how<br /><code>jquery.telemetry.js</code> works, it's also fairly well documented in source. To<br />use these files hot-linking is, however, not recommended. Distribute them on<br />your own and update them as the dashboard gets updated. It's only<br /><code>telemetry.js</code> that should be included from <code>telemetry.mozilla.org</code>.</p>"
    },
    "ignore": false,
    "code": "var Telemetry = {};\n\n// Release url from which people should include telemetry.js\nvar releaseURL = \"http://telemetry.mozilla.org/v1/telemetry.js\";\n\n// Check if the current browser includes telemetry.js from the release url.\n// ignore browsers that don't support `document.currentScript`, there is\n// probably not a lot of developers who use IE for development anyway.\nif (document.currentScript && document.currentScript.src != releaseURL) {\n  // Let's print a long grim warning message, hopefully people will pay\n  // attention, the issue is fairly well explained here.\n  console.log([\n    \"WARNING: telemetry.js is loaded in development mode, this should only be\",\n    \"use for telemetry.js development, not dashboard development, and never\",\n    \"in deployment! In order for telemetry.js to be automatically updated\",\n    \"whenever the server-side storage layout changes you must include \",\n    \"telemetry.js from:\",\n    releaseURL,\n    \"in exchange, we will aim for API compatibility whenever telemetry.js\",\n    \"is updated. This small change could keep your dashboard relevant for\",\n    \"years to come. Notice that telemetry.js does embed URLs pointing to\",\n    \"data folders on the server, and these URLs will be changed without\",\n    \"warning. The only supported way to include telemetry.js is from the\",\n    \"official source noted above. See documentation for further details.\"\n  ].join('\\n         '));\n}\n\n// Data folder from which data will be loaded, another level indicating current\n// folder will be initialized by Telemetry.init()\nvar _data_folder = 'https://s3-us-west-2.amazonaws.com/telemetry-dashboard/v4';\n\n// Map from channel/version to data prefix, loaded by Telemetry.init()\nvar _dataFolderMap = null;\n\n// List of versions present in _dataFolderMap\nvar _versions = null;",
    "ctx": {
      "type": "declaration",
      "name": "Telemetry",
      "value": "{}",
      "string": "Telemetry"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Auxiliary function to GET files from _data_folder</p>",
      "summary": "<p>Auxiliary function to GET files from _data_folder</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function _get(path, cb) {\n  // Check that we've been initialized\n  if(!_versions && path != \"versions.json\") {\n    throw new Error(\"Telemetry._get: Telemetry module haven't been \" +\n                    \"initialized, please call Telemetry.init()\");\n  }\n\n  // Create path from array, if that's what we're giving\n  if (path instanceof Array) {\n    path = path.join(\"/\");\n  }\n\n  // Create HTTP request\n  var xhr = new XMLHttpRequest();\n  xhr.onload = function (e) {\n    if (e.target.status == 200) {\n      cb.apply(this, [JSON.parse(this.responseText)]);\n    } else {\n      console.log(\"Telemetry._get: Failed loading \" + path + \" with \" +\n                  e.target.status);\n    }\n  };\n  xhr.open(\"get\", _data_folder + \"/\" + path, true);\n  xhr.send();\n}",
    "ctx": {
      "type": "function",
      "name": "_get",
      "string": "_get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Callback to be invoked after loading"
      }
    ],
    "description": {
      "full": "<p>Initialize telemetry module by fetching meta-data from server, <code>cb()</code> will be<br />invoked when Telemetry module is ready for use.</p>\n\n<p>You cannot use any of the methods in the <code>Telemetry</code> module before you have<br />initialized the module with this function.</p>\n\n<pre><code>Telemetry.init(function(){\n  // You can now use telemetry.js\n  alert(\"Versions available: \"Telemetry.versions().join(','));\n});\n</code></pre>\n\n<p>Once you've initialized <code>telemetry.js</code> you'll want to lookup available<br />channel, version combinations using <code>Telemetry.versions()</code>.</p>",
      "summary": "<p>Initialize telemetry module by fetching meta-data from server, <code>cb()</code> will be<br />invoked when Telemetry module is ready for use.</p>",
      "body": "<p>You cannot use any of the methods in the <code>Telemetry</code> module before you have<br />initialized the module with this function.</p>\n\n<pre><code>Telemetry.init(function(){\n  // You can now use telemetry.js\n  alert(\"Versions available: \"Telemetry.versions().join(','));\n});\n</code></pre>\n\n<p>Once you've initialized <code>telemetry.js</code> you'll want to lookup available<br />channel, version combinations using <code>Telemetry.versions()</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Telemetry.init = function Telemetry_load(cb) {\n  // Get map from channels/version to data folders from versions.json\n  _get(\"versions.json\", function(data) {\n    _dataFolderMap = data;\n    _versions = Object.keys(data).sort();\n    cb();\n  });\n};",
    "ctx": {
      "type": "method",
      "receiver": "Telemetry",
      "name": "init",
      "string": "Telemetry.init()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get a list of channel, version combinations available. This function returns<br />a list of strings on the form <code>'&lt;channel&gt;/&lt;version&gt;'</code>.</p>\n\n<p><strong>Example:</strong></p>\n\n<pre><code>Telemetry.versions()\n['release/24', 'release/25', 'release/26', ..., 'nightly/28']\n</code></pre>\n\n<p>The strings returned here can be passed to <code>Telemetry.measures()</code> in order<br />to get a list of measures available for the specific channel and version.<br />See, <code>Telemetry.measures()</code> for callback details.</p>",
      "summary": "<p>Get a list of channel, version combinations available. This function returns<br />a list of strings on the form <code>'&lt;channel&gt;/&lt;version&gt;'</code>.</p>",
      "body": "<p><strong>Example:</strong></p>\n\n<pre><code>Telemetry.versions()\n['release/24', 'release/25', 'release/26', ..., 'nightly/28']\n</code></pre>\n\n<p>The strings returned here can be passed to <code>Telemetry.measures()</code> in order<br />to get a list of measures available for the specific channel and version.<br />See, <code>Telemetry.measures()</code> for callback details.</p>"
    },
    "ignore": false,
    "code": "Telemetry.versions = function Telemetry_versions() {\n  if (_versions === null) {\n    throw new Error(\"Telemetry.versions: Telemetry module isn't initialized!\");\n  }\n  return _versions;\n};",
    "ctx": {
      "type": "method",
      "receiver": "Telemetry",
      "name": "versions",
      "string": "Telemetry.versions()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "channel_version",
        "description": "Channel/version string"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Callback to be invoked with result"
      }
    ],
    "description": {
      "full": "<p>Request measures available for a given <code>'&lt;channel&gt;/&lt;version&gt;'</code> string. The<br /><code>'&lt;channel&gt;/&lt;version&gt;'</code> must originate from the list returned by<br /><code>Telemetry.versions()</code>. Once the measures have been loaded the callback <code>cb</code><br />will be invoked as <code>cb(measures)</code> where <code>measures</code> a dictionary on the<br />following form:</p>\n\n<pre><code>{\n  \"A_TELEMETRY_MEASURE_ID\": {\n    kind:         \"linear|exponential|flag|enumerated|boolean\",\n    description:  \"A human readable description\"\n  },\n  ...\n}\n</code></pre>\n\n<p>The following example prints all <em>exponential</em> measures for nightly 25,<br />assuming the string <code>'nightly/25'</code> is in the list returned by<br /><code>Telemetry.versions()</code>.</p>\n\n<pre><code>Telemetry.measures('nightly/25', function(measures) {\n  for(var measure in measures) {\n    if(measures[measure].kind == 'exponential') {\n      // Log the measure id\n      console.log(measure);\n    }\n  }\n});\n</code></pre>\n\n<h3>Measure Identifiers</h3>\n\n<p>The measure id's are all in UPPER case like <code>A_TELEMETRY_MEASURE_ID</code>, along<br />with the selected <code>'&lt;channel&gt;/&lt;version&gt;'</code> string these can be provide to<br /><code>Telemetry.loadEvolutionOverBuilds</code> and <code>Telemetry.loadEvolutionOverTime</code> to<br />load histogram data sets.</p>\n\n<p>The measure ids with some exceptions lives in the tree along with definitions<br />and descriptions, see <code>toolkit/components/telemetry/Histograms.json</code>.<br /><strong>Do not</strong> use this <code>Histograms.json</code> in consumers of <code>telemetry.js</code>, all the<br />is carefully included and merged to account for changing revisions.</p>",
      "summary": "<p>Request measures available for a given <code>'&lt;channel&gt;/&lt;version&gt;'</code> string. The<br /><code>'&lt;channel&gt;/&lt;version&gt;'</code> must originate from the list returned by<br /><code>Telemetry.versions()</code>. Once the measures have been loaded the callback <code>cb</code><br />will be invoked as <code>cb(measures)</code> where <code>measures</code> a dictionary on the<br />following form:</p>",
      "body": "<pre><code>{\n  \"A_TELEMETRY_MEASURE_ID\": {\n    kind:         \"linear|exponential|flag|enumerated|boolean\",\n    description:  \"A human readable description\"\n  },\n  ...\n}\n</code></pre>\n\n<p>The following example prints all <em>exponential</em> measures for nightly 25,<br />assuming the string <code>'nightly/25'</code> is in the list returned by<br /><code>Telemetry.versions()</code>.</p>\n\n<pre><code>Telemetry.measures('nightly/25', function(measures) {\n  for(var measure in measures) {\n    if(measures[measure].kind == 'exponential') {\n      // Log the measure id\n      console.log(measure);\n    }\n  }\n});\n</code></pre>\n\n<h3>Measure Identifiers</h3>\n\n<p>The measure id's are all in UPPER case like <code>A_TELEMETRY_MEASURE_ID</code>, along<br />with the selected <code>'&lt;channel&gt;/&lt;version&gt;'</code> string these can be provide to<br /><code>Telemetry.loadEvolutionOverBuilds</code> and <code>Telemetry.loadEvolutionOverTime</code> to<br />load histogram data sets.</p>\n\n<p>The measure ids with some exceptions lives in the tree along with definitions<br />and descriptions, see <code>toolkit/components/telemetry/Histograms.json</code>.<br /><strong>Do not</strong> use this <code>Histograms.json</code> in consumers of <code>telemetry.js</code>, all the<br />is carefully included and merged to account for changing revisions.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Telemetry.measures = function Telemetry_measures(channel_version, cb) {\n  var data_folder = _dataFolderMap[channel_version];\n  _get([data_folder, \"histograms.json\"], function(data) {\n    var measures = {};\n\n    // For each measure fetched\n    for(var measure in data) {\n      // Add measure id\n      measures[measure] = {\n        kind:         data[measure].kind,\n        description:  data[measure].description\n      }\n    }\n\n    // Return measures by callback\n    cb(measures);\n  });\n};",
    "ctx": {
      "type": "method",
      "receiver": "Telemetry",
      "name": "measures",
      "string": "Telemetry.measures()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "channel_version",
        "description": "Channel/version string"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "measure",
        "description": "Measure identifier"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Callback to be invoked with result"
      }
    ],
    "description": {
      "full": "<p>Load a <code>Telemetry.HistogramEvolution</code> instance for a given channel, version<br />and measure. The <code>HistogramEvolution</code> instance will hold a collection of<br /><code>Histograms</code> over <strong>build dates</strong>. Use this function if you're interested in<br />the evolution of a histogram over different build ids, but notice that<br /><strong>build ids are reduced to dates</strong>. Hence, you cannot lookup a specific<br />build id - but for most channels there should only be one per day.</p>\n\n<p>If you don't care about evolution of the histogram over builds, but just the<br />aggregated histogram over all time or a histogram for a specific build date.<br />This is also the function you should use to load it, then call<br /><code>HistogramEvolution.range()</code> without any parameters to get an aggregated<br /><code>Histogram</code> instance over all builds.</p>\n\n<p>The <code>channel_version</code> parameter must be a string on the form<br /><code>'&lt;channel&gt;/&lt;version&gt;'</code> obtained from <code>Telemetry.versions()</code>. The <code>measure</code><br />parameter, most be a measure identifier obtained using<br /><code>Telemetry.measures(channel_version, ...)</code>. To load the <code>'CYCLE_COLLECTOR'</code><br />measure for nightly 25, proceed as follows:</p>\n\n<pre><code>Telemetry.loadEvolutionOverBuilds('nightly/25', 'CYCLE_COLLECTOR',\n                                  function(histogramEvolution) {\n  // See HistogramEvolution for how to read data, for example we can\n  // the build dates available as follows\n  console.log(histogramEvolution.dates());\n});\n</code></pre>\n\n<p><strong>Remark</strong> all telemetry pings for the given channel, version and measure are<br />aggregated in the <code>HistogramEvolution</code> instance obtained through<br /><code>loadEvolutionOverBuilds</code>. This is not the case for <code>loadEvolutionOverTime</code>.<br />The six week release cycle ensures that number of build dates is fairly<br />limited. However, this is not the case for submissions dates, as not all<br />Firefox users updates immediately. <strong>Thus</strong> if you just want the histogram<br /><strong>aggregated for all builds</strong>, you should use <code>loadEvolutionOverBuilds</code>.</p>",
      "summary": "<p>Load a <code>Telemetry.HistogramEvolution</code> instance for a given channel, version<br />and measure. The <code>HistogramEvolution</code> instance will hold a collection of<br /><code>Histograms</code> over <strong>build dates</strong>. Use this function if you're interested in<br />the evolution of a histogram over different build ids, but notice that<br /><strong>build ids are reduced to dates</strong>. Hence, you cannot lookup a specific<br />build id - but for most channels there should only be one per day.</p>",
      "body": "<p>If you don't care about evolution of the histogram over builds, but just the<br />aggregated histogram over all time or a histogram for a specific build date.<br />This is also the function you should use to load it, then call<br /><code>HistogramEvolution.range()</code> without any parameters to get an aggregated<br /><code>Histogram</code> instance over all builds.</p>\n\n<p>The <code>channel_version</code> parameter must be a string on the form<br /><code>'&lt;channel&gt;/&lt;version&gt;'</code> obtained from <code>Telemetry.versions()</code>. The <code>measure</code><br />parameter, most be a measure identifier obtained using<br /><code>Telemetry.measures(channel_version, ...)</code>. To load the <code>'CYCLE_COLLECTOR'</code><br />measure for nightly 25, proceed as follows:</p>\n\n<pre><code>Telemetry.loadEvolutionOverBuilds('nightly/25', 'CYCLE_COLLECTOR',\n                                  function(histogramEvolution) {\n  // See HistogramEvolution for how to read data, for example we can\n  // the build dates available as follows\n  console.log(histogramEvolution.dates());\n});\n</code></pre>\n\n<p><strong>Remark</strong> all telemetry pings for the given channel, version and measure are<br />aggregated in the <code>HistogramEvolution</code> instance obtained through<br /><code>loadEvolutionOverBuilds</code>. This is not the case for <code>loadEvolutionOverTime</code>.<br />The six week release cycle ensures that number of build dates is fairly<br />limited. However, this is not the case for submissions dates, as not all<br />Firefox users updates immediately. <strong>Thus</strong> if you just want the histogram<br /><strong>aggregated for all builds</strong>, you should use <code>loadEvolutionOverBuilds</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Telemetry.loadEvolutionOverBuilds = function(channel_version, measure, cb) {\n  // Number of files to load, and what to do when done\n  var load_count = 3;\n  var data, filter_tree, specifications;\n  function count_down() {\n    load_count--;\n    if (load_count === 0) {\n      cb(\n        new Telemetry.HistogramEvolution(\n          measure,\n          [measure],\n          data,\n          filter_tree,\n          specifications[measure]\n        )\n      );\n    }\n  }\n  // Find data folder for given channel/version\n  var data_folder = _dataFolderMap[channel_version];\n  // Load data for measure\n  _get([data_folder, measure + \"-by-build-date.json\"], function(json) {\n    data = json;\n    count_down();\n  });\n  // Load filter data\n  _get([data_folder, \"filter-tree.json\"], function(json) {\n    filter_tree = json;\n    count_down();\n  });\n  // Load histogram specifications\n  _get([data_folder, \"histograms.json\"], function(json) {\n    specifications = json;\n    count_down();\n  });\n};",
    "ctx": {
      "type": "method",
      "receiver": "Telemetry",
      "name": "loadEvolutionOverBuilds",
      "string": "Telemetry.loadEvolutionOverBuilds()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "channel_version",
        "description": "Channel/version string"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "measure",
        "description": "Measure identifier"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Callback to be invoked with result"
      }
    ],
    "description": {
      "full": "<p>Load a <code>Telemetry.HistogramEvolution</code> instance for a given channel, version<br />and measure. The <code>HistogramEvolution</code> instance will hold a collection of<br /><code>Histograms</code> over <em>calendar dates</em>. <strong>Do only</strong> use this function if you're<br />interested in the <strong>evolution of the internet</strong>! It can ofcourse be useful<br />to see if measures differ because of changes in the platform or changes in<br />the internet.</p>\n\n<p>If you don't care about evolution of the histogram over time, but just the<br />aggregated histogram over all time, you should <strong>not use this function</strong>.<br />Use <code>loadEvolutionOverBuilds</code> for this purpose!</p>\n\n<p>Only the first 60 days following the build date will be aggregated in<br /><code>HistogramEvolution</code> instances obtained through <code>loadEvolutionOverTime</code>.<br />As noted in \"Remark\" for <code>loadEvolutionOverBuilds</code> this is not the case for<br />that <code>HistogramEvolution</code> instances loaded through <code>loadEvolutionOverBuilds</code>.</p>\n\n<p>See <code>loadEvolutionOverBuilds</code> for example usage, the parameters are<br />equivalent. You can use the same parameters for both of them.</p>",
      "summary": "<p>Load a <code>Telemetry.HistogramEvolution</code> instance for a given channel, version<br />and measure. The <code>HistogramEvolution</code> instance will hold a collection of<br /><code>Histograms</code> over <em>calendar dates</em>. <strong>Do only</strong> use this function if you're<br />interested in the <strong>evolution of the internet</strong>! It can ofcourse be useful<br />to see if measures differ because of changes in the platform or changes in<br />the internet.</p>",
      "body": "<p>If you don't care about evolution of the histogram over time, but just the<br />aggregated histogram over all time, you should <strong>not use this function</strong>.<br />Use <code>loadEvolutionOverBuilds</code> for this purpose!</p>\n\n<p>Only the first 60 days following the build date will be aggregated in<br /><code>HistogramEvolution</code> instances obtained through <code>loadEvolutionOverTime</code>.<br />As noted in \"Remark\" for <code>loadEvolutionOverBuilds</code> this is not the case for<br />that <code>HistogramEvolution</code> instances loaded through <code>loadEvolutionOverBuilds</code>.</p>\n\n<p>See <code>loadEvolutionOverBuilds</code> for example usage, the parameters are<br />equivalent. You can use the same parameters for both of them.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Telemetry.loadEvolutionOverTime = function(channel_version, measure, cb) {\n  // Number of files to load, and what to do when done\n  var load_count = 3;\n  var data, filter_tree, specifications;\n  function count_down() {\n    load_count--;\n    if (load_count === 0) {\n      cb(\n        new Telemetry.HistogramEvolution(\n          measure,\n          [measure],\n          data,\n          filter_tree,\n          specifications[measure]\n        )\n      );\n    }\n  }\n  // Find data folder for given channel/version\n  var data_folder = _dataFolderMap[channel_version];\n  // Load data for measure\n  _get([data_folder, measure + \"-by-submission-date.json\"], function(json) {\n    data = json;\n    count_down();\n  });\n  // Load filter data\n  _get([data_folder, \"filter-tree.json\"], function(json) {\n    filter_tree = json;\n    count_down();\n  });\n  // Load histogram specifications\n  _get([data_folder, \"histograms.json\"], function(json) {\n    specifications = json;\n    count_down();\n  });\n};",
    "ctx": {
      "type": "method",
      "receiver": "Telemetry",
      "name": "loadEvolutionOverTime",
      "string": "Telemetry.loadEvolutionOverTime()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Auxiliary function to find all filter_ids in a filter_tree</p>",
      "summary": "<p>Auxiliary function to find all filter_ids in a filter_tree</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function _listFilterIds(filter_tree){\n  var ids = [];\n  function visitFilterNode(filter_node){\n    ids.push(filter_node._id);\n    for (var key in filter_node) {\n      if (key != \"name\" && key != \"_id\") {\n        visitFilterNode(filter_node[key]);\n      }\n    }\n  }\n  visitFilterNode(filter_tree);\n  return ids;\n}\n\n// Offset relative to length for special elements in arrays of raw data\nvar DataOffsets = {\n  SUM:            -7,   // The following keys are documented in StorageFormat.md\n  LOG_SUM:        -6,   // See the docs/ folder of the telemetry-server\n  LOG_SUM_SQ:     -5,   // Repository. They are essentially part of the\n  SUM_SQ_LO:      -4,   // validated telemetry histogram format\n  SUM_SQ_HI:      -3,\n  SUBMISSIONS:    -2,   // Added in deashboard.py\n  FILTER_ID:      -1    // Added in results2disk.py\n};",
    "ctx": {
      "type": "function",
      "name": "_listFilterIds",
      "string": "_listFilterIds()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A <code>HistogramEvolution</code> instance is a collection of histograms over dates.<br />These <em>dates</em> can be either build dates or submission dates, depending on<br />whether <code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> was used to<br />obtained the <code>HistogramEvolution</code> instance. For an example of how to obtain<br />an instance of this type see <code>loadEvolutionOverBuilds</code>.</p>\n\n<p>When you have a <code>HistogramEvolution</code> instance, you can <code>filter</code> it by<br />available <code>filterOptions</code>. You can iterate over dates and histograms with<br /><code>each</code>, or aggregated histograms between dates with <code>range</code>. If you don't<br />care about dates and just want an aggregated histogram for all dates, you<br />can call <code>range()</code> with no arguments, interpreted as the open ended interval.<br />Which in this example prints the total number of submissions aggregated.</p>\n\n<pre><code>Telemetry.loadEvolutionOverBuilds('nightly/25', 'CYCLE_COLLECTOR',\n                                  function(histogramEvolution) {\n  // Get submissions from a histogram aggregated over all dates\n  // in the HistogramEvolution instance\n  var histogram = histogramEvolution.range();\n  console.log(histogram.submissions());\n});\n</code></pre>\n\n<p>Notice, that when you have obtained an instance of <code>HistogramEvolution</code> all<br />operations on this instance and any objects created by it are synchronous<br />and doesn't require any network communication.</p>\n\n<p><strong>Remark</strong> you should never instantiate <code>Telemetry.Histogram</code> instances on<br />your own. The constructor is exposed to facilitate use with <code>instanceof</code>,<br />parameters taken by the constructor is not part of the public stable<br /><code>telemetry.js</code> API.</p>",
      "summary": "<p>A <code>HistogramEvolution</code> instance is a collection of histograms over dates.<br />These <em>dates</em> can be either build dates or submission dates, depending on<br />whether <code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> was used to<br />obtained the <code>HistogramEvolution</code> instance. For an example of how to obtain<br />an instance of this type see <code>loadEvolutionOverBuilds</code>.</p>",
      "body": "<p>When you have a <code>HistogramEvolution</code> instance, you can <code>filter</code> it by<br />available <code>filterOptions</code>. You can iterate over dates and histograms with<br /><code>each</code>, or aggregated histograms between dates with <code>range</code>. If you don't<br />care about dates and just want an aggregated histogram for all dates, you<br />can call <code>range()</code> with no arguments, interpreted as the open ended interval.<br />Which in this example prints the total number of submissions aggregated.</p>\n\n<pre><code>Telemetry.loadEvolutionOverBuilds('nightly/25', 'CYCLE_COLLECTOR',\n                                  function(histogramEvolution) {\n  // Get submissions from a histogram aggregated over all dates\n  // in the HistogramEvolution instance\n  var histogram = histogramEvolution.range();\n  console.log(histogram.submissions());\n});\n</code></pre>\n\n<p>Notice, that when you have obtained an instance of <code>HistogramEvolution</code> all<br />operations on this instance and any objects created by it are synchronous<br />and doesn't require any network communication.</p>\n\n<p><strong>Remark</strong> you should never instantiate <code>Telemetry.Histogram</code> instances on<br />your own. The constructor is exposed to facilitate use with <code>instanceof</code>,<br />parameters taken by the constructor is not part of the public stable<br /><code>telemetry.js</code> API.</p>"
    },
    "ignore": false,
    "code": "Telemetry.HistogramEvolution = (function(){",
    "ctx": {
      "type": "property",
      "receiver": "Telemetry",
      "name": "HistogramEvolution",
      "value": "(function(){",
      "string": "Telemetry.HistogramEvolution"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Auxiliary function to parse a date string from JSON data format</p>",
      "summary": "<p>Auxiliary function to parse a date string from JSON data format</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function _parseDateString(d) {\n  return new Date(d.substr(0,4) + \"/\" + d.substr(4,2) + \"/\"+ d.substr(6,2));\n}",
    "ctx": {
      "type": "function",
      "name": "_parseDateString",
      "string": "_parseDateString()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Auxiliary function to compute all bucket ends from a specification<br />This returns a list [b0, b1, ..., bn] where b0 is the separator value between<br />entries in bucket index 0 and bucket index 1. Such that all values less than<br />b0 was counted in bucket 0, values greater than counted in bucket 1.</p>",
      "summary": "<p>Auxiliary function to compute all bucket ends from a specification<br />This returns a list [b0, b1, ..., bn] where b0 is the separator value between<br />entries in bucket index 0 and bucket index 1. Such that all values less than<br />b0 was counted in bucket 0, values greater than counted in bucket 1.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function _computeBuckets(spec){\n  // Find bounds from specification\n  var low = 1, high, nbuckets;\n  if(spec.kind == 'boolean' || spec.kind == 'flag') {\n    // This is how boolean bucket indexes are generated in mozilla-central we\n    // might look into whether or not there is a bug, as it seems rather weird\n    // that boolean histograms have 3 buckets.\n    high      = 2;\n    nbuckets  = 3;\n  } else if (spec.kind == 'enumerated') {\n    high      = eval(spec.n_values);\n    nbuckets  = eval(spec.n_values) + 1;\n  } else if (spec.kind == 'linear' || spec.kind == 'exponential') {\n    low       = eval(spec.low) || 1;\n    high      = eval(spec.high);\n    nbuckets  = eval(spec.n_buckets)\n  }\n  // Compute buckets\n  var buckets = null;\n  if(spec.kind == 'exponential') {\n    // Exponential buckets is a special case\n    var log_max = Math.log(high);\n    buckets = [0, low];\n    var current = low;\n    for(var i = 2; i < nbuckets; i++) {\n      var log_current = Math.log(current);\n      var log_ratio   = (log_max - log_current) / (nbuckets - i);\n      var log_next    = log_current + log_ratio;\n      var next_value  = Math.floor(Math.exp(log_next) + 0.5);\n      if (next_value > current) {\n        current = next_value;\n      } else {\n        current = current + 1;\n      }\n      buckets.push(current);\n    }\n  } else {\n    // Linear buckets are computed as follows\n    buckets = [0];\n    for(var i = 1; i < nbuckets; i++) {\n      var range = (low * (nbuckets - 1 - i) + high * (i - 1));\n      buckets[i] = (Math.floor(range / (nbuckets - 2) + 0.5));\n    }\n  }\n  return buckets;\n}",
    "ctx": {
      "type": "function",
      "name": "_computeBuckets",
      "string": "_computeBuckets()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Create a histogram evolution, where<br /> - measure       is the name of this histogram,<br /> - filter_path   is a list of [name, date-range, filter1, filter2...]<br /> - data          is the JSON data loaded from file,<br /> - filter_tree   is the filter_tree root, and<br /> - spec          is the histogram specification.</p>",
      "summary": "<p>Create a histogram evolution, where<br /> - measure       is the name of this histogram,<br /> - filter_path   is a list of [name, date-range, filter1, filter2...]<br /> - data          is the JSON data loaded from file,<br /> - filter_tree   is the filter_tree root, and<br /> - spec          is the histogram specification.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function HistogramEvolution(measure, filter_path, data, filter_tree, spec) {\n  this._measure     = measure\n  this._filter_path = filter_path;\n  this._data        = data;\n  this._filter_tree = filter_tree;\n  this._spec        = spec;\n  this._buckets     = _computeBuckets(spec);\n}",
    "ctx": {
      "type": "function",
      "name": "HistogramEvolution",
      "string": "HistogramEvolution()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the measure for histograms in this <code>HistogramEvolution</code> instance.</p>\n\n<p>This is the measure id given when this instance was created by either<br /><code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code>. You'll also find this<br />measure id in the results obtained from <code>Telemetry.measures</code>.</p>\n\n<p>See <code>Telemetry.measures</code> for more information on measure ids.</p>",
      "summary": "<p>Get the measure for histograms in this <code>HistogramEvolution</code> instance.</p>",
      "body": "<p>This is the measure id given when this instance was created by either<br /><code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code>. You'll also find this<br />measure id in the results obtained from <code>Telemetry.measures</code>.</p>\n\n<p>See <code>Telemetry.measures</code> for more information on measure ids.</p>"
    },
    "ignore": false,
    "code": "HistogramEvolution.prototype.measure = function HistogramEvolution_measure() {\n  return this._measure;\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "measure",
      "string": "HistogramEvolution.prototype.measure()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the histogram kind, possible histogram kinds are:</p>\n\n<ul>\n<li><code>'linear'</code></li>\n<li><code>'exponential'</code></li>\n<li><code>'flag'</code></li>\n<li><code>'enumerated'</code></li>\n<li><code>'boolean'</code></li>\n</ul>\n\n<p><strong>Notice</strong> some methods will throw exceptions if used on a histogram with an<br />unsupported <em>\"kind\"</em>. For example it doesn't make sense to estimate<br />percentiles for boolean histograms, and doing so will throw an exception.</p>\n\n<pre><code>// Create a plot of 25'th percentile, if we have 'linear' histogram.\nvar data_points = null;\nif(histogramEvolution.kind() == 'linear') {\n  data_points = histogramEvolution.map(function(date, histogram, index) {\n    return {x: date.getTime(), y: histogram.percentile(25)};\n  });\n}\n</code></pre>",
      "summary": "<p>Get the histogram kind, possible histogram kinds are:</p>",
      "body": "<ul>\n<li><code>'linear'</code></li>\n<li><code>'exponential'</code></li>\n<li><code>'flag'</code></li>\n<li><code>'enumerated'</code></li>\n<li><code>'boolean'</code></li>\n</ul>\n\n<p><strong>Notice</strong> some methods will throw exceptions if used on a histogram with an<br />unsupported <em>\"kind\"</em>. For example it doesn't make sense to estimate<br />percentiles for boolean histograms, and doing so will throw an exception.</p>\n\n<pre><code>// Create a plot of 25'th percentile, if we have 'linear' histogram.\nvar data_points = null;\nif(histogramEvolution.kind() == 'linear') {\n  data_points = histogramEvolution.map(function(date, histogram, index) {\n    return {x: date.getTime(), y: histogram.percentile(25)};\n  });\n}\n</code></pre>"
    },
    "ignore": false,
    "code": "HistogramEvolution.prototype.kind = function HistogramEvolution_kind() {\n  return this._spec.kind;\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "kind",
      "string": "HistogramEvolution.prototype.kind()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get a human readable description of the measure in this histogram.</p>\n\n<p>This is the same description as offered by <code>Telemetry.measures</code>, it is<br />defined in <code>Histograms.json</code>, see section on measure identifiers in<br /><code>Telemetry.measures</code>.</p>",
      "summary": "<p>Get a human readable description of the measure in this histogram.</p>",
      "body": "<p>This is the same description as offered by <code>Telemetry.measures</code>, it is<br />defined in <code>Histograms.json</code>, see section on measure identifiers in<br /><code>Telemetry.measures</code>.</p>"
    },
    "ignore": false,
    "code": "HistogramEvolution.prototype.description = function() {\n  return this._spec.description;\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "description",
      "string": "HistogramEvolution.prototype.description()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Name of filter available, <code>null</code> if no filter is available.</p>\n\n<pre><code>// Check to see if a filter is available, assuming histogramEvolution is\n// an instance of HistogramEvolution\nvar filterName = histogramEvolution.filterName();\nif (filterName !== null) {\n  alert(\"Current filter available: \" + filterName);\n} else {\n  alert(\"No filter available!\");\n}\n</code></pre>\n\n<p>The aggregated histograms are stored in a filter tree, you can apply one<br />filter at the time <em>drilling down</em> the aggregated data. Each application of<br />a filter returns a new <code>HistogramEvolution</code> instance.</p>\n\n<p>You should <strong>always</strong> use <code>filterName</code> and <code>filterOptions</code> get name of the<br />next filter, if any, and available filter options, if any. But as of writing<br />filters offered are:</p>\n\n<ol>\n<li><code>'reason'</code>, reason for telemetry ping submission (e.g. <code>'session_saved'</code>)</li>\n<li><code>'appName'</code>, application name (e.g. <code>'Firefox'</code>)</li>\n<li><code>'OS'</code>, operation system (e.g. <code>'Linux'</code>)</li>\n<li><code>'osVersion'</code>, operation system version (e.g. <code>'3.2'</code>)</li>\n<li><code>'arch'</code>, architecture (e.g. <code>'x86-64'</code>)</li>\n</ol>\n\n<p><strong>Warning</strong> filter availability, ordering may change at any time,<br /><code>telemetry.js</code> offers a stable API to interface them through <code>filterName</code>,<br /><code>filterOptions</code> and <code>filter</code>, use these instead of hardcoding your filters!</p>",
      "summary": "<p>Name of filter available, <code>null</code> if no filter is available.</p>",
      "body": "<pre><code>// Check to see if a filter is available, assuming histogramEvolution is\n// an instance of HistogramEvolution\nvar filterName = histogramEvolution.filterName();\nif (filterName !== null) {\n  alert(\"Current filter available: \" + filterName);\n} else {\n  alert(\"No filter available!\");\n}\n</code></pre>\n\n<p>The aggregated histograms are stored in a filter tree, you can apply one<br />filter at the time <em>drilling down</em> the aggregated data. Each application of<br />a filter returns a new <code>HistogramEvolution</code> instance.</p>\n\n<p>You should <strong>always</strong> use <code>filterName</code> and <code>filterOptions</code> get name of the<br />next filter, if any, and available filter options, if any. But as of writing<br />filters offered are:</p>\n\n<ol>\n<li><code>'reason'</code>, reason for telemetry ping submission (e.g. <code>'session_saved'</code>)</li>\n<li><code>'appName'</code>, application name (e.g. <code>'Firefox'</code>)</li>\n<li><code>'OS'</code>, operation system (e.g. <code>'Linux'</code>)</li>\n<li><code>'osVersion'</code>, operation system version (e.g. <code>'3.2'</code>)</li>\n<li><code>'arch'</code>, architecture (e.g. <code>'x86-64'</code>)</li>\n</ol>\n\n<p><strong>Warning</strong> filter availability, ordering may change at any time,<br /><code>telemetry.js</code> offers a stable API to interface them through <code>filterName</code>,<br /><code>filterOptions</code> and <code>filter</code>, use these instead of hardcoding your filters!</p>"
    },
    "ignore": false,
    "code": "HistogramEvolution.prototype.filterName = function() {\n  return this._filter_tree.name || null;\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "filterName",
      "string": "HistogramEvolution.prototype.filterName()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>List of options available for current filter, empty list if none or no filter<br />is available.</p>\n\n<p>Each option is a string, for example the <code>'reason'</code> filter will as of writing<br />offer options <code>'idle_daily'</code> and <code>'saved_session'</code>.<br />You may pass an option to <code>HistogramEvolution.filter</code> if you want to filter<br />by it or, as in this example, show options to the user.</p>\n\n<pre><code>// Present user with filter options available, if filter is available\nif (histogramEvolution.filterName() !== null) {\n  var options = histogramEvolution.filterOptions();\n  alert(\"Available filter options: \" + options.join(\", \"));\n}\n</code></pre>\n\n<p><strong>Warning</strong> filter options names changes based submission, do not hard code<br />these, if you want to <em>drill down</em> to your interesting segment, do create<br />an automatic strategy for doing so based on substrings with fall-back to<br />something sane. When, filtering you should <strong>always</strong> use a value returned<br />by this method. Otherwise, your application may break in the future, filter<br />option names will change over time.</p>",
      "summary": "<p>List of options available for current filter, empty list if none or no filter<br />is available.</p>",
      "body": "<p>Each option is a string, for example the <code>'reason'</code> filter will as of writing<br />offer options <code>'idle_daily'</code> and <code>'saved_session'</code>.<br />You may pass an option to <code>HistogramEvolution.filter</code> if you want to filter<br />by it or, as in this example, show options to the user.</p>\n\n<pre><code>// Present user with filter options available, if filter is available\nif (histogramEvolution.filterName() !== null) {\n  var options = histogramEvolution.filterOptions();\n  alert(\"Available filter options: \" + options.join(\", \"));\n}\n</code></pre>\n\n<p><strong>Warning</strong> filter options names changes based submission, do not hard code<br />these, if you want to <em>drill down</em> to your interesting segment, do create<br />an automatic strategy for doing so based on substrings with fall-back to<br />something sane. When, filtering you should <strong>always</strong> use a value returned<br />by this method. Otherwise, your application may break in the future, filter<br />option names will change over time.</p>"
    },
    "ignore": false,
    "code": "HistogramEvolution.prototype.filterOptions = function() {\n  var options = [];\n  for (var key in this._filter_tree) {\n    if (key != \"name\" && key != \"_id\") {\n      options.push(key);\n    }\n  }\n  return options.sort();\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "filterOptions",
      "string": "HistogramEvolution.prototype.filterOptions()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "option",
        "description": "Option you want result filter by"
      }
    ],
    "description": {
      "full": "<p>Get a <code>HistogramEvolution</code> instance filtered by <code>option</code>.</p>\n\n<p>The <code>option</code> parameter <strong>must</strong> be a string returned by the <code>filterOptions</code><br />method on this object. It may be tempting to hard code these options, but<br />this <strong>not</strong> recommended, as available options may change at any time.<br />Instead use <code>filterOptions</code> to query for available options, and pick one.</p>\n\n<p>If you filter the a <code>HistogramEvolution</code> instance by two different options,<br />you should get two disjoint aggregates. The following example demonstrates<br />this feature, as the number of submissions in each filtered result must sum<br />up to the number of submissions in the unfiltered aggregated histogram.</p>\n\n<pre><code>// Loop over all available filter options\nhistogramEvolution.filterOptions().forEach(function(option) {\n  // Filter by option, returning a new HistogramEvolution instance\n  var filteredHistogramEvolution = histogramEvolution.filter(option);\n\n  // Get aggregated histogram for all dates in filtered histogram\n  // evolution as obtained above\n  var filteredHistogram = filteredHistogramEvolution.range();\n\n  // Get submissions from aggregated (and filtered) histogram\n  var submissions = filterHistogram.submissions();\n  console.log(option + \" has \" + submissions + \" submissions\");\n});\n\n// Get aggregated (unfiltered) histogram\nvar histogram = histogramEvolution.range();\nvar submissions = histogram.submissions();\nconsole.log(\"In total: \" + submissions + \" submissions\");\n</code></pre>\n\n<p><strong>Remark</strong> this method will not modify the existing <code>HistogramEvolution</code><br />instance, but return a new instance of <code>HistogramEvolution</code> filtered by the<br />given <code>option</code>.</p>",
      "summary": "<p>Get a <code>HistogramEvolution</code> instance filtered by <code>option</code>.</p>",
      "body": "<p>The <code>option</code> parameter <strong>must</strong> be a string returned by the <code>filterOptions</code><br />method on this object. It may be tempting to hard code these options, but<br />this <strong>not</strong> recommended, as available options may change at any time.<br />Instead use <code>filterOptions</code> to query for available options, and pick one.</p>\n\n<p>If you filter the a <code>HistogramEvolution</code> instance by two different options,<br />you should get two disjoint aggregates. The following example demonstrates<br />this feature, as the number of submissions in each filtered result must sum<br />up to the number of submissions in the unfiltered aggregated histogram.</p>\n\n<pre><code>// Loop over all available filter options\nhistogramEvolution.filterOptions().forEach(function(option) {\n  // Filter by option, returning a new HistogramEvolution instance\n  var filteredHistogramEvolution = histogramEvolution.filter(option);\n\n  // Get aggregated histogram for all dates in filtered histogram\n  // evolution as obtained above\n  var filteredHistogram = filteredHistogramEvolution.range();\n\n  // Get submissions from aggregated (and filtered) histogram\n  var submissions = filterHistogram.submissions();\n  console.log(option + \" has \" + submissions + \" submissions\");\n});\n\n// Get aggregated (unfiltered) histogram\nvar histogram = histogramEvolution.range();\nvar submissions = histogram.submissions();\nconsole.log(\"In total: \" + submissions + \" submissions\");\n</code></pre>\n\n<p><strong>Remark</strong> this method will not modify the existing <code>HistogramEvolution</code><br />instance, but return a new instance of <code>HistogramEvolution</code> filtered by the<br />given <code>option</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "HistogramEvolution.prototype.filter = function histogramEvolution_filter(opt) {\n  if (!(this._filter_tree[opt] instanceof Object)) {\n    throw new Error(\"filter option: \\\"\" + opt +\"\\\" is not available\");\n  }\n  return new HistogramEvolution(\n    this._measure,\n    this._filter_path.concat(opt),\n    this._data,\n    this._filter_tree[opt],\n    this._spec\n  );\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "filter",
      "string": "HistogramEvolution.prototype.filter()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the list of dates for which this <code>HistogramEvolution</code> instance holds<br />histograms. You can get the histograms with the <code>each()</code> method or aggregate<br />them with the <code>range()</code> method.</p>\n\n<p>Depending on whether this <code>HistogramEvolution</code> instance was obtained from<br /><code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> the dates returned are<br />build dates or submissions dates, respectively.</p>\n\n<p>This method <strong>returns</strong> a list of Javascript <code>Date</code> objects. So you can<br />format them as you please. This examples prints the dates for which a<br /><code>HistogramEvolution</code> instance has histograms.</p>\n\n<pre><code>// Get list of dates available\nvar dates = histogramEvolution.dates();\ndates.forEach(function(date) {\n  console.log(date.toString());\n});\n</code></pre>\n\n<p><strong>Remark</strong>, when you apply filters to an instance of <code>HistogramEvolution</code> the<br />resulting (filtered) <code>HistogramEvolution</code> instance, <em>may</em> not hold all the<br />same dates. This usually happens if we have very little data from a  given<br />date. See <code>HistogramEvolution.filter</code> for more on filtering.</p>",
      "summary": "<p>Get the list of dates for which this <code>HistogramEvolution</code> instance holds<br />histograms. You can get the histograms with the <code>each()</code> method or aggregate<br />them with the <code>range()</code> method.</p>",
      "body": "<p>Depending on whether this <code>HistogramEvolution</code> instance was obtained from<br /><code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> the dates returned are<br />build dates or submissions dates, respectively.</p>\n\n<p>This method <strong>returns</strong> a list of Javascript <code>Date</code> objects. So you can<br />format them as you please. This examples prints the dates for which a<br /><code>HistogramEvolution</code> instance has histograms.</p>\n\n<pre><code>// Get list of dates available\nvar dates = histogramEvolution.dates();\ndates.forEach(function(date) {\n  console.log(date.toString());\n});\n</code></pre>\n\n<p><strong>Remark</strong>, when you apply filters to an instance of <code>HistogramEvolution</code> the<br />resulting (filtered) <code>HistogramEvolution</code> instance, <em>may</em> not hold all the<br />same dates. This usually happens if we have very little data from a  given<br />date. See <code>HistogramEvolution.filter</code> for more on filtering.</p>"
    },
    "ignore": false,
    "code": "HistogramEvolution.prototype.dates = function HistogramEvolution_dates() {\n  var dates = [];\n  for(var date in this._data) {\n    dates.push(_parseDateString(date));\n  }\n  return dates.sort();\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "dates",
      "string": "HistogramEvolution.prototype.dates()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Date"
        ],
        "name": "start",
        "description": "Optional, date to aggregate from"
      },
      {
        "type": "param",
        "types": [
          "Date"
        ],
        "name": "end",
        "description": "Optinoal, date to aggregate to"
      }
    ],
    "description": {
      "full": "<p>Get a <code>Histogram</code> instance with aggregated values over date interval starting<br />from <code>start</code> and ending with <code>end</code>, both <code>start</code> and <code>end</code> are inclusive.</p>\n\n<p>It is important to understand that <code>null</code> is interpreted as parameter<br />omission and used to get an open-ended interval. Hence, calling <code>range()</code><br />without any parameters returns a <code>Telemetry.Histogram</code> instance with<br />aggregated values for all dates hold by this instance of<br /><code>HistogramEvolution</code>. See, below for other example.</p>\n\n<pre><code>// Alert the user to number of submissions in histogramEvolution\nvar aggregatedHistogram = histogramEvolution.range();\nvar total = aggregatedHistogram.submissions();\nalert(\"We have a total of \" + total + \" submissions\")\n\n// Ask the user to pick a date split date\nvar date = new Date(prompt(\"Please enter a split date:\"));\n\n// Now, alert the user the the number of submissions before and on date\naggregatedHistogram = histogramEvolution.range(null, date);\nvar before = aggregatedHistogram.submissions();\nalert(\"We have \" + before + \" on and before the entered date\");\n\n// Let's alert the user the the number of submissions after and on date\naggregatedHistogram = histogramEvolution.range(date);\nvar after = aggregatedHistogram.submissions();\nalert(\"We have \" + after + \" on and after the entered date\");\n\n// How about the number of submission on the date\naggregatedHistogram = histogramEvolution.range(date, date);\nvar on = aggregatedHistogram.submissions();\nalert(\"We have \" + on + \" on the entered date\");\n</code></pre>\n\n<p><strong>Notice</strong> that <code>telemetry.js</code> only cares about the date, not time of day,<br />and while <code>Date</code> objects also stores the time of day, this part of the <code>Date</code><br />object will be ignored.</p>",
      "summary": "<p>Get a <code>Histogram</code> instance with aggregated values over date interval starting<br />from <code>start</code> and ending with <code>end</code>, both <code>start</code> and <code>end</code> are inclusive.</p>",
      "body": "<p>It is important to understand that <code>null</code> is interpreted as parameter<br />omission and used to get an open-ended interval. Hence, calling <code>range()</code><br />without any parameters returns a <code>Telemetry.Histogram</code> instance with<br />aggregated values for all dates hold by this instance of<br /><code>HistogramEvolution</code>. See, below for other example.</p>\n\n<pre><code>// Alert the user to number of submissions in histogramEvolution\nvar aggregatedHistogram = histogramEvolution.range();\nvar total = aggregatedHistogram.submissions();\nalert(\"We have a total of \" + total + \" submissions\")\n\n// Ask the user to pick a date split date\nvar date = new Date(prompt(\"Please enter a split date:\"));\n\n// Now, alert the user the the number of submissions before and on date\naggregatedHistogram = histogramEvolution.range(null, date);\nvar before = aggregatedHistogram.submissions();\nalert(\"We have \" + before + \" on and before the entered date\");\n\n// Let's alert the user the the number of submissions after and on date\naggregatedHistogram = histogramEvolution.range(date);\nvar after = aggregatedHistogram.submissions();\nalert(\"We have \" + after + \" on and after the entered date\");\n\n// How about the number of submission on the date\naggregatedHistogram = histogramEvolution.range(date, date);\nvar on = aggregatedHistogram.submissions();\nalert(\"We have \" + on + \" on the entered date\");\n</code></pre>\n\n<p><strong>Notice</strong> that <code>telemetry.js</code> only cares about the date, not time of day,<br />and while <code>Date</code> objects also stores the time of day, this part of the <code>Date</code><br />object will be ignored.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "HistogramEvolution.prototype.range = function (start, end) {\n  // If start is given, we reduce it to year, month and day, this prevents\n  // ensure that less-then-or-equal operator works as expected, in corner cases\n  // where people submit dates that holds a none-zero timestamp\n  if(start) {\n    start = new Date(start.getFullYear(), start.getMonth(), start.getDate());\n  }\n\n  // Sanitize end too\n  if(end) {\n    end = new Date(end.getFullYear(), end.getMonth(), end.getDate());\n  }\n\n  // Construct a dataset by merging all datasets/histograms in the range\n  var merged_dataset = [];\n\n  // List of filter_ids we care about, instead of just merging all filters\n  var filter_ids = _listFilterIds(this._filter_tree);\n\n  // For each date we have to merge the filter_ids into merged_dataset\n  for (var datekey in this._data) {\n\n    // Check that date is between start and end (if start and end is defined)\n    var date = _parseDateString(datekey);\n    if((!start || start <= date) && (!end || date <= end)) {\n\n      // Find dataset of this datekey, merge filter_ids for this dataset into\n      // merged_dataset.\n      var dataset = this._data[datekey];\n\n      // Copy all data arrays over... we'll filter and aggregate later\n      merged_dataset = merged_dataset.concat(dataset);\n    }\n  }\n\n  // Create merged histogram\n  return new Telemetry.Histogram(\n    this._measure,\n    this._filter_path,\n    this._buckets,\n    merged_dataset,\n    this._filter_tree,\n    this._spec\n  );\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "range",
      "string": "HistogramEvolution.prototype.range()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Callback to be invoked with histograms"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "ctx",
        "description": "Optional, context for the callback"
      }
    ],
    "description": {
      "full": "<p>Iterate over dates and histograms, ordered by date, by having <code>cb</code> invoked as<br /><code>cb(date, histogram, index)</code> for each <code>Date</code>, <code>Telemetry.Histogram</code> pair held<br />by this <code>HistogramEvolution</code> instance.</p>\n\n<p>Depending on whether <code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> was<br />used to obtained the <code>HistogramEvolution</code> instance, the date will be a build<br />date or submission date, respectively. The <code>index</code> is an integer starting<br />from <code>0</code> and incremented by one for each invocation of <code>cb</code>.</p>\n\n<p>The following example demonstrates how to print the evolution in number of<br />submissions over dates for a <code>HistogramEvolution</code> instance.</p>\n\n<pre><code>histogramEvolution.each(function(date, histogram, index) {\n  console.log(histogram.submissions() + \" on the \" + date.toString());\n});\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>HistogramEvolution</code> instance as context.</p>",
      "summary": "<p>Iterate over dates and histograms, ordered by date, by having <code>cb</code> invoked as<br /><code>cb(date, histogram, index)</code> for each <code>Date</code>, <code>Telemetry.Histogram</code> pair held<br />by this <code>HistogramEvolution</code> instance.</p>",
      "body": "<p>Depending on whether <code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> was<br />used to obtained the <code>HistogramEvolution</code> instance, the date will be a build<br />date or submission date, respectively. The <code>index</code> is an integer starting<br />from <code>0</code> and incremented by one for each invocation of <code>cb</code>.</p>\n\n<p>The following example demonstrates how to print the evolution in number of<br />submissions over dates for a <code>HistogramEvolution</code> instance.</p>\n\n<pre><code>histogramEvolution.each(function(date, histogram, index) {\n  console.log(histogram.submissions() + \" on the \" + date.toString());\n});\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>HistogramEvolution</code> instance as context.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "HistogramEvolution.prototype.each = function HistogramEvolution_each(cb, ctx) {\n  // Set this as context if none is provided\n  if (ctx === undefined) {\n    ctx = this;\n  }\n\n  // Find and sort all date strings\n  var dates = [];\n  for(var date in this._data) {\n    dates.push(date);\n  }\n  dates.sort();\n\n  // Find filter ids\n  var filterIds = _listFilterIds(this._filter_tree);\n\n  // Auxiliary function to filter data arrays by filter_id\n  function filterByFilterId(data_array) {\n      var filterId = data_array[data_array.length + DataOffsets.FILTER_ID];\n      return filterIds.indexOf(filterId) != -1;\n  }\n\n  // Pair index, this is not equal to i as we may have filtered something out\n  var index = 0;\n\n  // Now invoke cb with each histogram\n  var n = dates.length;\n  for(var i = 0; i < n; i++) {\n    // Get dataset for date\n    var dataset = this._data[dates[i]];\n\n    // Filter for data_arrays with relevant filterId\n    dataset = dataset.filter(filterByFilterId);\n\n    // Skip this date if there was not data_array after filtering as applied\n    if (dataset.length === 0) {\n      continue;\n    }\n\n    // Invoke callback with date and histogram\n    cb.call(\n      ctx,\n      _parseDateString(dates[i]),\n      new Telemetry.Histogram(\n        this._measure,\n        this._filter_path,\n        this._buckets,\n        dataset,\n        this._filter_tree,\n        this._spec\n      ),\n      index++\n    );\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "each",
      "string": "HistogramEvolution.prototype.each()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Mapping to be invoked with histograms"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "ctx",
        "description": "Optional, context for the callback"
      }
    ],
    "description": {
      "full": "<p>Map date, histogram pairs held by this <code>HistogramEvolution</code> instance to an<br />array (ordered by date). Essentially, <code>cb</code> is invoked as<br /><code>cb(date, histogram, index)</code> for each <code>Date</code>, <code>Telemetry.Histogram</code> pair, in<br />ordered of increasing date, and the return value from <code>cb</code> is appened to an<br />array, which is then then returned by <code>map()</code>.</p>\n\n<p>Depending on whether <code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> was<br />used to obtained the <code>HistogramEvolution</code> instance, the date will be a build<br />date or submission date, respectively. The <code>index</code> is an integer starting<br />from <code>0</code> and incremented by one for each invocation of <code>cb</code>.</p>\n\n<p>This is quite similar to what <code>HistogramEvolution.each()</code> does, except the<br />return values from <code>cb</code> are stored in an array, returned by <code>map()</code> when it<br />it finished. As the following example shows this is very useful for creating<br />arrays of points to plot.</p>\n\n<pre><code>// Let's create a list of {x: ..., y: ...} data points of submissions and\n// timestamps to plot with any common Javascript library.\nvar data = histogramEvolution.map(function(date, histogram, index) {\n  return {\n    x:  date.getTime(), // Use get unix timestamp\n    y:  histogram.submissions()\n  };\n});\n// Use your favorite graph library to plot `data`\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>HistogramEvolution</code> instance as context.</p>\n\n<h3>Performance Considerations</h3>\n\n<p>Behind the scenes <code>Telemetry.Histogram</code> instances holds a list of histograms<br />for different dates and filters, as you drill-down the number of dates and<br />filters, histograms are excluded from consideration. This makes filtering<br />and instantiation of <code>Histogram</code> instances very fast, as a <code>Histogram</code> is<br />essentially just a virtual view of existing data.</p>\n\n<p>However, whenever you access data on a <code>Telemetry.Histogram</code> instance the<br />view will be lazily materialized behind the scenes. This is great for<br />performance, unless, <code>Histogram</code> instance is immediately discarded.</p>\n\n<p>So while it may be tempting to use <code>HistogramEvolution.map</code> once for each<br />series you want to plot. It is often much better to use<br /><code>HistogramEvolution.each</code> and reused the materialized view. See the good/bad<br />examples below for illustration.</p>\n\n<p><strong>Bad example</strong>, the example below offers poor performance because the<br /><code>Histogram</code> instances are created twice and as we access data on these<br />instances, hence, the underlying view is materialized twice.</p>\n\n<pre><code>// Get a list of means and a list of medians (bad performing example)\nvar means = histogramEvolution.map(function(date, histogram, index) {\n  return histogram.mean();\n});\nvar medians = histogramEvolution.map(function(date, histogram, index) {\n  return histogram.median();\n});\n// Now, we can plot means and medians\n</code></pre>\n\n<p><strong>Good example</strong>, the example below offers better performance because only<br />one <code>Histogram</code> instance is created per data point, hence, the materialized<br />view lazily created for computation of <code>mean</code> can be reused for estimation<br /><code>median</code>.</p>\n\n<pre><code>// Create a list of means and a list of medians (good performing example)\nvar means   = [],\n    medians = [];\nhistogramEvolution.each(function(date, histogram, index) {\n  means[index]    = histogram.mean();\n  medians[index]  = histogram.medians();\n});\n// Now, we can plot means and medians\n</code></pre>\n\n<p>The above example is just to illustrate a common performance trap with <code>map</code>,<br />there are many legitimate uses for <code>map</code>.</p>",
      "summary": "<p>Map date, histogram pairs held by this <code>HistogramEvolution</code> instance to an<br />array (ordered by date). Essentially, <code>cb</code> is invoked as<br /><code>cb(date, histogram, index)</code> for each <code>Date</code>, <code>Telemetry.Histogram</code> pair, in<br />ordered of increasing date, and the return value from <code>cb</code> is appened to an<br />array, which is then then returned by <code>map()</code>.</p>",
      "body": "<p>Depending on whether <code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code> was<br />used to obtained the <code>HistogramEvolution</code> instance, the date will be a build<br />date or submission date, respectively. The <code>index</code> is an integer starting<br />from <code>0</code> and incremented by one for each invocation of <code>cb</code>.</p>\n\n<p>This is quite similar to what <code>HistogramEvolution.each()</code> does, except the<br />return values from <code>cb</code> are stored in an array, returned by <code>map()</code> when it<br />it finished. As the following example shows this is very useful for creating<br />arrays of points to plot.</p>\n\n<pre><code>// Let's create a list of {x: ..., y: ...} data points of submissions and\n// timestamps to plot with any common Javascript library.\nvar data = histogramEvolution.map(function(date, histogram, index) {\n  return {\n    x:  date.getTime(), // Use get unix timestamp\n    y:  histogram.submissions()\n  };\n});\n// Use your favorite graph library to plot `data`\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>HistogramEvolution</code> instance as context.</p>\n\n<h3>Performance Considerations</h3>\n\n<p>Behind the scenes <code>Telemetry.Histogram</code> instances holds a list of histograms<br />for different dates and filters, as you drill-down the number of dates and<br />filters, histograms are excluded from consideration. This makes filtering<br />and instantiation of <code>Histogram</code> instances very fast, as a <code>Histogram</code> is<br />essentially just a virtual view of existing data.</p>\n\n<p>However, whenever you access data on a <code>Telemetry.Histogram</code> instance the<br />view will be lazily materialized behind the scenes. This is great for<br />performance, unless, <code>Histogram</code> instance is immediately discarded.</p>\n\n<p>So while it may be tempting to use <code>HistogramEvolution.map</code> once for each<br />series you want to plot. It is often much better to use<br /><code>HistogramEvolution.each</code> and reused the materialized view. See the good/bad<br />examples below for illustration.</p>\n\n<p><strong>Bad example</strong>, the example below offers poor performance because the<br /><code>Histogram</code> instances are created twice and as we access data on these<br />instances, hence, the underlying view is materialized twice.</p>\n\n<pre><code>// Get a list of means and a list of medians (bad performing example)\nvar means = histogramEvolution.map(function(date, histogram, index) {\n  return histogram.mean();\n});\nvar medians = histogramEvolution.map(function(date, histogram, index) {\n  return histogram.median();\n});\n// Now, we can plot means and medians\n</code></pre>\n\n<p><strong>Good example</strong>, the example below offers better performance because only<br />one <code>Histogram</code> instance is created per data point, hence, the materialized<br />view lazily created for computation of <code>mean</code> can be reused for estimation<br /><code>median</code>.</p>\n\n<pre><code>// Create a list of means and a list of medians (good performing example)\nvar means   = [],\n    medians = [];\nhistogramEvolution.each(function(date, histogram, index) {\n  means[index]    = histogram.mean();\n  medians[index]  = histogram.medians();\n});\n// Now, we can plot means and medians\n</code></pre>\n\n<p>The above example is just to illustrate a common performance trap with <code>map</code>,<br />there are many legitimate uses for <code>map</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "HistogramEvolution.prototype.map = function HistogramEvolution_map(cb, ctx) {\n  // Set this as context if none is provided\n  if (ctx === undefined) {\n    ctx = this;\n  }\n\n  // Return value array\n  var results = [];\n\n  // For each date, histogram pair invoke cb() and add result to results\n  this.each(function(date, histogram, index) {\n    results.push(cb.call(ctx, date, histogram, index));\n  });\n\n  // Return array of computed values\n  return results;\n};\n\nreturn HistogramEvolution;\n\n})();",
    "ctx": {
      "type": "method",
      "constructor": "HistogramEvolution",
      "cons": "HistogramEvolution",
      "name": "map",
      "string": "HistogramEvolution.prototype.map()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Representation of a histogram is a set of buckets with intervals a count for<br />number of hits in each bucket.</p>\n\n<p>Consider a measure measure the amount of time a given operation takes, for<br />such a measure the first bucket may start at zero and end at 1 ms, then<br /><em>count</em> of the first bucket is the number of times the operation finished<br />between 0 and 1ms. See <a href=\"http://en.wikipedia.org/wiki/Histogram\">histogram</a><br />for deeper explanation of histograms.</p>\n\n<p>A <code>Telemetry.Histogram</code> instance can be obtained from an instance of<br /><code>Telemetry.HistogramEvolution</code>, see <code>loadEvolutionOverBuilds</code> or<br /><code>loadEvolutionOverTime</code> for how to obtain one of those.</p>\n\n<p>When you have a <code>Histogram</code> instance, you can <code>filter</code> it by available<br /><code>filterOptions</code>. You can iterate over buckets and counts with<br /><code>each</code>, compute statistics such as <code>mean</code>, standardDeviation<code>or estimate<br />more complicated statistics like</code>median<code>and</code>percentile`'s.</p>\n\n<p>The following example demonstrates how to obtain a <code>Histogram</code> instance and<br />print the number of telemetry submissions aggregated in the histogram.</p>\n\n<pre><code>Telemetry.loadEvolutionOverBuilds('nightly/25', 'CYCLE_COLLECTOR',\n                                  function(histogramEvolution) {\n  // Get submissions from a histogram aggregated over all dates\n  // in the HistogramEvolution instance\n  var histogram = histogramEvolution.range();\n\n  // Now log the number of submissions aggregated in the histogram\n  console.log(histogram.submissions());\n});\n</code></pre>\n\n<p>The above example is just an illustration, you should not hard-code<br />the <code>'&lt;channel&gt;/&lt;version&gt;'</code> or measure identifier strings. Valid values for<br />these parameters can be obtained from <code>Telemetry.versions</code> and<br /><code>Telemetry.measures</code>.</p>\n\n<p><strong>Remark</strong> you should never instantiate <code>Telemetry.Histogram</code> instances on<br />your own. The constructor is exposed to facilitate use with <code>instanceof</code>,<br />parameters taken by the constructor is not part of the public stable<br /><code>telemetry.js</code> API.</p>",
      "summary": "<p>Representation of a histogram is a set of buckets with intervals a count for<br />number of hits in each bucket.</p>",
      "body": "<p>Consider a measure measure the amount of time a given operation takes, for<br />such a measure the first bucket may start at zero and end at 1 ms, then<br /><em>count</em> of the first bucket is the number of times the operation finished<br />between 0 and 1ms. See <a href=\"http://en.wikipedia.org/wiki/Histogram\">histogram</a><br />for deeper explanation of histograms.</p>\n\n<p>A <code>Telemetry.Histogram</code> instance can be obtained from an instance of<br /><code>Telemetry.HistogramEvolution</code>, see <code>loadEvolutionOverBuilds</code> or<br /><code>loadEvolutionOverTime</code> for how to obtain one of those.</p>\n\n<p>When you have a <code>Histogram</code> instance, you can <code>filter</code> it by available<br /><code>filterOptions</code>. You can iterate over buckets and counts with<br /><code>each</code>, compute statistics such as <code>mean</code>, standardDeviation<code>or estimate<br />more complicated statistics like</code>median<code>and</code>percentile`'s.</p>\n\n<p>The following example demonstrates how to obtain a <code>Histogram</code> instance and<br />print the number of telemetry submissions aggregated in the histogram.</p>\n\n<pre><code>Telemetry.loadEvolutionOverBuilds('nightly/25', 'CYCLE_COLLECTOR',\n                                  function(histogramEvolution) {\n  // Get submissions from a histogram aggregated over all dates\n  // in the HistogramEvolution instance\n  var histogram = histogramEvolution.range();\n\n  // Now log the number of submissions aggregated in the histogram\n  console.log(histogram.submissions());\n});\n</code></pre>\n\n<p>The above example is just an illustration, you should not hard-code<br />the <code>'&lt;channel&gt;/&lt;version&gt;'</code> or measure identifier strings. Valid values for<br />these parameters can be obtained from <code>Telemetry.versions</code> and<br /><code>Telemetry.measures</code>.</p>\n\n<p><strong>Remark</strong> you should never instantiate <code>Telemetry.Histogram</code> instances on<br />your own. The constructor is exposed to facilitate use with <code>instanceof</code>,<br />parameters taken by the constructor is not part of the public stable<br /><code>telemetry.js</code> API.</p>"
    },
    "ignore": false,
    "code": "Telemetry.Histogram = (function(){",
    "ctx": {
      "type": "property",
      "receiver": "Telemetry",
      "name": "Histogram",
      "value": "(function(){",
      "string": "Telemetry.Histogram"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Auxiliary function to aggregate values of index from histogram dataset</p>",
      "summary": "<p>Auxiliary function to aggregate values of index from histogram dataset</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function _aggregate(index, histogram) {\n  if (histogram._aggregated === undefined) {\n    histogram._aggregated = [];\n  }\n  var sum = histogram._aggregated[index];\n  if (sum === undefined) {\n    // Cache the list of filter ids\n    if (histogram._filterIds === undefined) {\n      histogram._filterIds = _listFilterIds(histogram._filter_tree);\n    }\n    // Aggregate index as sum over histogram\n    sum = 0;\n    var n = histogram._dataset.length;\n    for(var i = 0; i < n; i++) {\n      var data_array = histogram._dataset[i];\n\n      // Check if filter_id is filtered\n      var filter_id_offset = data_array.length + DataOffsets.FILTER_ID;\n      if (histogram._filterIds.indexOf(data_array[filter_id_offset]) != -1) {\n        sum += data_array[index >= 0 ? index : data_array.length + index];\n      }\n    }\n    histogram._aggregated[index] = sum;\n  }\n  return sum;\n}",
    "ctx": {
      "type": "function",
      "name": "_aggregate",
      "string": "_aggregate()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Auxiliary function for estimating the end of the last bucket</p>",
      "summary": "<p>Auxiliary function for estimating the end of the last bucket</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function _estimateLastBucketEnd(histogram) {\n  // As there is no next bucket for the last bucket, we sometimes need to\n  // estimate one. First we estimate the sum of all data-points in buckets\n  // below the last bucket\n  var sum_before_last = 0;\n  var n = histogram._buckets.length;\n  for (var i = 0; i < n - 1; i++) {\n    var bucket_center = (histogram._buckets[i+1] - histogram._buckets[i]) / 2 +\n                         histogram._buckets[i];\n    sum_before_last += _aggregate(i, histogram) * bucket_center;\n  }\n  // We estimate the sum of data-points in the last bucket by subtracting the\n  // estimate of sum of data-points before the last bucket...\n  var sum_last = _aggregate(DataOffsets.SUM, histogram) - sum_before_last;\n  // We estimate the mean of the last bucket as follows\n  var last_bucket_mean = sum_last / _aggregate(n - 1, histogram);\n  // We find the start of the last bucket\n  var last_bucket_start = histogram._buckets[n - 1];\n  // Now estimate the last bucket end\n  return last_bucket_start + (last_bucket_mean - last_bucket_start) * 2;\n}",
    "ctx": {
      "type": "function",
      "name": "_estimateLastBucketEnd",
      "string": "_estimateLastBucketEnd()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Create a new histogram, where<br /> - measure       is the name of the histogram,<br /> - filter_path   is a list of [name, date-range, filter1, filter2...]<br /> - buckets       is a list of bucket start values,<br /> - dataset       is a mapping from filter ids to arrays of raw data<br /> - filter_tree   is a node in filter tree structure, and<br /> - spec          is the histogram specification.</p>",
      "summary": "<p>Create a new histogram, where<br /> - measure       is the name of the histogram,<br /> - filter_path   is a list of [name, date-range, filter1, filter2...]<br /> - buckets       is a list of bucket start values,<br /> - dataset       is a mapping from filter ids to arrays of raw data<br /> - filter_tree   is a node in filter tree structure, and<br /> - spec          is the histogram specification.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function Histogram(measure, filter_path, buckets, dataset, filter_tree, spec) {\n  this._measure     = measure;\n  this._filter_path = filter_path;\n  this._buckets     = buckets;\n  this._dataset     = dataset;\n  this._filter_tree = filter_tree;\n  this._spec        = spec;\n}",
    "ctx": {
      "type": "function",
      "name": "Histogram",
      "string": "Histogram()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the measure aggregated in this <code>Histogram</code> instance.</p>\n\n<p>This is the measure id given when the data was loaded by either<br /><code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code>. You'll also find this<br />measure id in the results obtained from <code>Telemetry.measures</code>.</p>\n\n<p>See <code>Telemetry.measures</code> for more information on measure ids.</p>",
      "summary": "<p>Get the measure aggregated in this <code>Histogram</code> instance.</p>",
      "body": "<p>This is the measure id given when the data was loaded by either<br /><code>loadEvolutionOverBuilds</code> or <code>loadEvolutionOverTime</code>. You'll also find this<br />measure id in the results obtained from <code>Telemetry.measures</code>.</p>\n\n<p>See <code>Telemetry.measures</code> for more information on measure ids.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.measure = function Histogram_measure() {\n  return this._measure;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "measure",
      "string": "Histogram.prototype.measure()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the histogram kind, possible histogram kinds are:</p>\n\n<ul>\n<li><code>'linear'</code></li>\n<li><code>'exponential'</code></li>\n<li><code>'flag'</code></li>\n<li><code>'enumerated'</code></li>\n<li><code>'boolean'</code></li>\n</ul>\n\n<p><strong>Notice</strong> some methods will throw exceptions if used on a histogram with an<br />unsupported <em>\"kind\"</em>. For example it doesn't make sense to estimate<br />percentiles for boolean histograms, and doing so will throw an exception.</p>\n\n<pre><code>// Print the mean, if we have 'linear' histogram.\nif(histogram.kind() == 'linear') {\n  console.log(\"mean value: \" + histogram.mean());\n}\n</code></pre>",
      "summary": "<p>Get the histogram kind, possible histogram kinds are:</p>",
      "body": "<ul>\n<li><code>'linear'</code></li>\n<li><code>'exponential'</code></li>\n<li><code>'flag'</code></li>\n<li><code>'enumerated'</code></li>\n<li><code>'boolean'</code></li>\n</ul>\n\n<p><strong>Notice</strong> some methods will throw exceptions if used on a histogram with an<br />unsupported <em>\"kind\"</em>. For example it doesn't make sense to estimate<br />percentiles for boolean histograms, and doing so will throw an exception.</p>\n\n<pre><code>// Print the mean, if we have 'linear' histogram.\nif(histogram.kind() == 'linear') {\n  console.log(\"mean value: \" + histogram.mean());\n}\n</code></pre>"
    },
    "ignore": false,
    "code": "Histogram.prototype.kind = function Histogram_kind() {\n  return this._spec.kind;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "kind",
      "string": "Histogram.prototype.kind()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get a human readable description of the measure in this histogram.</p>\n\n<p>This is the same description as offered by <code>Telemetry.measures</code>, it is<br />defined in <code>Histograms.json</code>, see section on measure identifiers in<br /><code>Telemetry.measures</code>.</p>",
      "summary": "<p>Get a human readable description of the measure in this histogram.</p>",
      "body": "<p>This is the same description as offered by <code>Telemetry.measures</code>, it is<br />defined in <code>Histograms.json</code>, see section on measure identifiers in<br /><code>Telemetry.measures</code>.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.description = function Histogram_description() {\n  return this._spec.description;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "description",
      "string": "Histogram.prototype.description()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Name of filter available, <code>null</code> if no filter is available.</p>\n\n<pre><code>// Check to see if a filter is available, assuming histogram is\n// an instance of Histogram\nvar filterName = histogram.filterName();\nif (filterName !== null) {\n  alert(\"Current filter available: \" + filterName);\n} else {\n  alert(\"No filter available!\");\n}\n</code></pre>\n\n<p>The aggregated histograms are stored in a filter tree, you can apply one<br />filter at the time <em>drilling down</em> the aggregated data. Each application of<br />a filter returns a new <code>Histogram</code> instance.</p>\n\n<p>You should <strong>always</strong> use <code>filterName</code> and <code>filterOptions</code> get name of the<br />next filter, if any, and available filter options, if any. But as of writing<br />filters offered are:</p>\n\n<ol>\n<li><code>'reason'</code>, reason for telemetry ping submission (e.g. <code>'session_saved'</code>)</li>\n<li><code>'appName'</code>, application name (e.g. <code>'Firefox'</code>)</li>\n<li><code>'OS'</code>, operation system (e.g. <code>'Linux'</code>)</li>\n<li><code>'osVersion'</code>, operation system version (e.g. <code>'3.2'</code>)</li>\n<li><code>'arch'</code>, architecture (e.g. <code>'x86-64'</code>)</li>\n</ol>\n\n<p><strong>Warning</strong> filter availability, ordering may change at any time,<br /><code>telemetry.js</code> offers a stable API to interface them through <code>filterName</code>,<br /><code>filterOptions</code> and <code>filter</code>, use these instead of hardcoding your filters!</p>",
      "summary": "<p>Name of filter available, <code>null</code> if no filter is available.</p>",
      "body": "<pre><code>// Check to see if a filter is available, assuming histogram is\n// an instance of Histogram\nvar filterName = histogram.filterName();\nif (filterName !== null) {\n  alert(\"Current filter available: \" + filterName);\n} else {\n  alert(\"No filter available!\");\n}\n</code></pre>\n\n<p>The aggregated histograms are stored in a filter tree, you can apply one<br />filter at the time <em>drilling down</em> the aggregated data. Each application of<br />a filter returns a new <code>Histogram</code> instance.</p>\n\n<p>You should <strong>always</strong> use <code>filterName</code> and <code>filterOptions</code> get name of the<br />next filter, if any, and available filter options, if any. But as of writing<br />filters offered are:</p>\n\n<ol>\n<li><code>'reason'</code>, reason for telemetry ping submission (e.g. <code>'session_saved'</code>)</li>\n<li><code>'appName'</code>, application name (e.g. <code>'Firefox'</code>)</li>\n<li><code>'OS'</code>, operation system (e.g. <code>'Linux'</code>)</li>\n<li><code>'osVersion'</code>, operation system version (e.g. <code>'3.2'</code>)</li>\n<li><code>'arch'</code>, architecture (e.g. <code>'x86-64'</code>)</li>\n</ol>\n\n<p><strong>Warning</strong> filter availability, ordering may change at any time,<br /><code>telemetry.js</code> offers a stable API to interface them through <code>filterName</code>,<br /><code>filterOptions</code> and <code>filter</code>, use these instead of hardcoding your filters!</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.filterName = function Histogram_filterName() {\n  return this._filter_tree.name || null;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "filterName",
      "string": "Histogram.prototype.filterName()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>List of options available for current filter, empty list if none or no filter<br />is available.</p>\n\n<p>Each option is a string, for example the <code>'reason'</code> filter will as of writing<br />offer options <code>'idle_daily'</code> and <code>'saved_session'</code>.<br />You may pass an option to <code>Histogram.filter</code> if you want to filter by it or,<br />as in this example, show options to the user.</p>\n\n<pre><code>// Present user with filter options available, if filter is available\nif (histogram.filterName() !== null) {\n  var options = histogram.filterOptions();\n  alert(\"Available filter options: \" + options.join(\", \"));\n}\n</code></pre>\n\n<p><strong>Warning</strong> filter options names changes based submission, do not hard code<br />these, if you want to <em>drill down</em> to your interesting segment, do create<br />an automatic strategy for doing so based on substrings with fall-back to<br />something sane. When, filtering you should <strong>always</strong> use a value returned<br />by this method. Otherwise, your application may break in the future, filter<br />option names will change over time.</p>",
      "summary": "<p>List of options available for current filter, empty list if none or no filter<br />is available.</p>",
      "body": "<p>Each option is a string, for example the <code>'reason'</code> filter will as of writing<br />offer options <code>'idle_daily'</code> and <code>'saved_session'</code>.<br />You may pass an option to <code>Histogram.filter</code> if you want to filter by it or,<br />as in this example, show options to the user.</p>\n\n<pre><code>// Present user with filter options available, if filter is available\nif (histogram.filterName() !== null) {\n  var options = histogram.filterOptions();\n  alert(\"Available filter options: \" + options.join(\", \"));\n}\n</code></pre>\n\n<p><strong>Warning</strong> filter options names changes based submission, do not hard code<br />these, if you want to <em>drill down</em> to your interesting segment, do create<br />an automatic strategy for doing so based on substrings with fall-back to<br />something sane. When, filtering you should <strong>always</strong> use a value returned<br />by this method. Otherwise, your application may break in the future, filter<br />option names will change over time.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.filterOptions = function Histogram_filterOptions() {\n  var options = [];\n  for (var key in this._filter_tree) {\n    if (key != \"name\" && key != \"_id\") {\n      options.push(key);\n    }\n  }\n  return options.sort();\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "filterOptions",
      "string": "Histogram.prototype.filterOptions()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "option",
        "description": "Option you want result filter by"
      }
    ],
    "description": {
      "full": "<p>Get a <code>Histogram</code> instance filtered by <code>option</code>.</p>\n\n<p>The <code>option</code> parameter <strong>must</strong> be a string returned by the <code>filterOptions</code><br />method on this object. It may be tempting to hard code these options, but<br />this <strong>not</strong> recommended, as available options may change at any time.<br />Instead use <code>filterOptions</code> to query for available options, and pick one.</p>\n\n<p>If you filter the a <code>Histogram</code> instance by two different options, you should<br />get two disjoint aggregates. The following example demonstrates this feature,<br />as the number of submissions in each filtered result must sum up to the<br />number of submissions in the unfiltered aggregated histogram.</p>\n\n<pre><code>// Loop over all available filter options\nhistogram.filterOptions().forEach(function(option) {\n  // Filter by option, returning a new Histogram instance\n  var filteredHistogram = histogram.filter(option);\n\n  // Get submissions from the filtered histogram\n  var submissions = filterHistogram.submissions();\n  console.log(option + \" has \" + submissions + \" submissions\");\n});\n\n// Get show submission in the unfiltered histogram\nvar submissions = histogram.submissions();\nconsole.log(\"In total: \" + submissions + \" submissions\");\n</code></pre>\n\n<p><strong>Remark</strong> this method will not modify the existing <code>Histogram</code> instance, but<br />return a new instance of <code>Histogram</code> filtered by the given <code>option</code>.</p>",
      "summary": "<p>Get a <code>Histogram</code> instance filtered by <code>option</code>.</p>",
      "body": "<p>The <code>option</code> parameter <strong>must</strong> be a string returned by the <code>filterOptions</code><br />method on this object. It may be tempting to hard code these options, but<br />this <strong>not</strong> recommended, as available options may change at any time.<br />Instead use <code>filterOptions</code> to query for available options, and pick one.</p>\n\n<p>If you filter the a <code>Histogram</code> instance by two different options, you should<br />get two disjoint aggregates. The following example demonstrates this feature,<br />as the number of submissions in each filtered result must sum up to the<br />number of submissions in the unfiltered aggregated histogram.</p>\n\n<pre><code>// Loop over all available filter options\nhistogram.filterOptions().forEach(function(option) {\n  // Filter by option, returning a new Histogram instance\n  var filteredHistogram = histogram.filter(option);\n\n  // Get submissions from the filtered histogram\n  var submissions = filterHistogram.submissions();\n  console.log(option + \" has \" + submissions + \" submissions\");\n});\n\n// Get show submission in the unfiltered histogram\nvar submissions = histogram.submissions();\nconsole.log(\"In total: \" + submissions + \" submissions\");\n</code></pre>\n\n<p><strong>Remark</strong> this method will not modify the existing <code>Histogram</code> instance, but<br />return a new instance of <code>Histogram</code> filtered by the given <code>option</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Histogram.prototype.filter = function Histogram_filter(option) {\n  if (!(this._filter_tree[option] instanceof Object)) {\n    throw new Error(\"filter option: \\\"\" + option +\"\\\" is not available\");\n  }\n  return new Histogram(\n    this._measure,\n    this._filter_path.concat(option),\n    this._buckets,\n    this._dataset,\n    this._filter_tree[option],\n    this._spec\n  );\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "filter",
      "string": "Histogram.prototype.filter()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Returns the number of telemetry pings aggregated in this histogram</p>\n\n<p>Notice that each <em>telemetry ping</em> contains a histogram of it own with<br />multiple measurements. That is, a telemetry ping usually contains many hits<br />in multiple buckets. It is only for simple measurements that the number of<br />submissions is equal to hits in all buckets.</p>\n\n<p>For example, if filtered with <code>'reason'</code> as <code>'session_saved'</code> the number of<br />submissions is the number session aggregated in this histogram.</p>",
      "summary": "<p>Returns the number of telemetry pings aggregated in this histogram</p>",
      "body": "<p>Notice that each <em>telemetry ping</em> contains a histogram of it own with<br />multiple measurements. That is, a telemetry ping usually contains many hits<br />in multiple buckets. It is only for simple measurements that the number of<br />submissions is equal to hits in all buckets.</p>\n\n<p>For example, if filtered with <code>'reason'</code> as <code>'session_saved'</code> the number of<br />submissions is the number session aggregated in this histogram.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.submissions = function Histogram_submissions() {\n  return _aggregate(DataOffsets.SUBMISSIONS, this);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "submissions",
      "string": "Histogram.prototype.submissions()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get number of data points in this histogram.</p>\n\n<p>This method returns the number of measurements in this histogram. That is the<br />number of hits in all buckets. For simple measurements, this is usually equal<br />to the number of submissions.</p>",
      "summary": "<p>Get number of data points in this histogram.</p>",
      "body": "<p>This method returns the number of measurements in this histogram. That is the<br />number of hits in all buckets. For simple measurements, this is usually equal<br />to the number of submissions.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.count = function Histogram_count() {\n  var count = 0;\n  var n = this._buckets.length;\n  for(var i = 0; i < n; i++) {\n    count += _aggregate(i, this);\n  }\n  return count;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "count",
      "string": "Histogram.prototype.count()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Returns the <a href=\"http://en.wikipedia.org/wiki/Mean\">mean</a> of all data points in<br />this histogram.</p>\n\n<p>The <em>mean</em> is computed using special statistics collected by telemetry in<br />gecko.  This means that the computed mean value is exact, as oppose to<br /><code>median</code> and <code>percentile</code> which are <em>estimated</em>.</p>\n\n<pre><code>// Print mean if available\nif (histogram.kind() == 'linear' || histogram.kind() == 'exponential') {\n  console.log(\"mean: \" + histogram.mean());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> and<br /><code>'exponential'</code> histograms, see <code>Histogram.kind()</code> to see what kind of<br />histogram you have. Invoking this method on any other kind of histogram will<br />throw an exception.</p>",
      "summary": "<p>Returns the <a href=\"http://en.wikipedia.org/wiki/Mean\">mean</a> of all data points in<br />this histogram.</p>",
      "body": "<p>The <em>mean</em> is computed using special statistics collected by telemetry in<br />gecko.  This means that the computed mean value is exact, as oppose to<br /><code>median</code> and <code>percentile</code> which are <em>estimated</em>.</p>\n\n<pre><code>// Print mean if available\nif (histogram.kind() == 'linear' || histogram.kind() == 'exponential') {\n  console.log(\"mean: \" + histogram.mean());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> and<br /><code>'exponential'</code> histograms, see <code>Histogram.kind()</code> to see what kind of<br />histogram you have. Invoking this method on any other kind of histogram will<br />throw an exception.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.mean = function Histogram_mean() {\n  if (this.kind() != \"linear\" && this.kind() != \"exponential\") {\n     throw new Error(\"Histogram.geometricMean() is only available for \" +\n                     \"linear and exponential histograms\");\n  }\n  var sum = _aggregate(DataOffsets.SUM, this);\n  return sum / this.count();\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "mean",
      "string": "Histogram.prototype.mean()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the <a href=\"http://en.wikipedia.org/wiki/Standard_deviation\">standard deviation</a><br />over all data points in this histogram.</p>\n\n<p>This method <strong>depends on</strong> <code>big.js</code> for high-precision integer arithmetics.<br />You can download <code>big.js</code> from <a href=\"https://github.com/MikeMcl/big.js/\">here</a>,<br />but the library is usually also included with <code>telemetry.js</code>.</p>\n\n<pre><code>// Print standard deviation if available\nif (histogram.kind() == 'linear') {\n  console.log(\"std dev: \" + histogram.mean());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> histograms, see<br /><code>Histogram.kind()</code> to see what kind of histogram you have. Invoking this<br />method on any other kind of histogram will throw an exception.</p>",
      "summary": "<p>Get the <a href=\"http://en.wikipedia.org/wiki/Standard_deviation\">standard deviation</a><br />over all data points in this histogram.</p>",
      "body": "<p>This method <strong>depends on</strong> <code>big.js</code> for high-precision integer arithmetics.<br />You can download <code>big.js</code> from <a href=\"https://github.com/MikeMcl/big.js/\">here</a>,<br />but the library is usually also included with <code>telemetry.js</code>.</p>\n\n<pre><code>// Print standard deviation if available\nif (histogram.kind() == 'linear') {\n  console.log(\"std dev: \" + histogram.mean());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> histograms, see<br /><code>Histogram.kind()</code> to see what kind of histogram you have. Invoking this<br />method on any other kind of histogram will throw an exception.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.standardDeviation = function Histogram_standardDeviation() {\n  if (this.kind() != \"linear\") {\n    throw new Error(\"Histogram.standardDeviation() is only available for \" +\n                    \"linear histograms\");\n  }\n  // Get big from global scope, and check that is available\n  var Big = exports.Big;\n  if (Big === undefined) {\n    throw new Error(\"Histogram.standardDeviation() requires big.js from: \" +\n                    \"https://github.com/MikeMcl/big.js/\");\n  }\n  var sum       = new Big(_aggregate(DataOffsets.SUM, this));\n  var count     = new Big(this.count());\n  var sum_sq_hi = new Big(_aggregate(DataOffsets.SUM_SQ_HI, this));\n  var sum_sq_lo = new Big(_aggregate(DataOffsets.SUM_SQ_LO, this));\n  var sum_sq    = sum_sq_lo.plus(sum_sq_hi.times(new Big(2).pow(32)));\n\n  // std. dev. = sqrt(count * sum_squares - sum * sum) / count\n  // http://en.wikipedia.org/wiki/Standard_deviation#Rapid_calculation_methods\n  var std_dev = count.times(sum_sq).minus(sum.pow(2)).div(count);\n  return parseFloat(std_dev.toFixed(3));\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "standardDeviation",
      "string": "Histogram.prototype.standardDeviation()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Get the <a href=\"http://en.wikipedia.org/wiki/Geometric_mean\">geometric mean</a> of all<br />data points in this histogram.</p>\n\n<pre><code>// Print geometric mean if available\nif (histogram.kind() == 'exponential') {\n  console.log(\"Geo mean: \" + histogram.geometricMean());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'exponential'</code> histograms,<br />see <code>Histogram.kind()</code> to see what kind of histogram you have. Invoking this<br />method on any other kind of histogram will throw an exception.</p>",
      "summary": "<p>Get the <a href=\"http://en.wikipedia.org/wiki/Geometric_mean\">geometric mean</a> of all<br />data points in this histogram.</p>",
      "body": "<pre><code>// Print geometric mean if available\nif (histogram.kind() == 'exponential') {\n  console.log(\"Geo mean: \" + histogram.geometricMean());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'exponential'</code> histograms,<br />see <code>Histogram.kind()</code> to see what kind of histogram you have. Invoking this<br />method on any other kind of histogram will throw an exception.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.geometricMean = function Histogram_geometricMean() {\n  if (this.kind() != \"exponential\") {\n    throw new Error(\"Histogram.geometricMean() is only available for \" +\n                    \"exponential histograms\");\n  }\n  var log_sum = _aggregate(DataOffsets.LOG_SUM, this);\n  return log_sum / this.count();\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "geometricMean",
      "string": "Histogram.prototype.geometricMean()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Return the <a href=\"http://en.wikipedia.org/wiki/Geometric_standard_deviation\">geometric standard deviation<br /></a><br />over all data points in this histogram.</p>\n\n<pre><code>// Print geometric standard deviation if available\nif (histogram.kind() == 'exponential') {\n  console.log(\"Geo std dev: \" + histogram.geometricStandardDeviation());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'exponential'</code> histograms,<br />see <code>Histogram.kind()</code> to see what kind of histogram you have. Invoking this<br />method on any other kind of histogram will throw an exception.</p>",
      "summary": "<p>Return the <a href=\"http://en.wikipedia.org/wiki/Geometric_standard_deviation\">geometric standard deviation<br /></a><br />over all data points in this histogram.</p>",
      "body": "<pre><code>// Print geometric standard deviation if available\nif (histogram.kind() == 'exponential') {\n  console.log(\"Geo std dev: \" + histogram.geometricStandardDeviation());\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'exponential'</code> histograms,<br />see <code>Histogram.kind()</code> to see what kind of histogram you have. Invoking this<br />method on any other kind of histogram will throw an exception.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.geometricStandardDeviation = function() {\n  if (this.kind() != 'exponential') {\n    throw new Error(\n      \"Histogram.geometricStandardDeviation() is only \" +\n      \"available for exponential histograms\"\n    );\n  }\n  var count       = this.count();\n  var log_sum     = _aggregate(DataOffsets.LOG_SUM, this);\n  var log_sum_sq  = _aggregate(DataOffsets.LOG_SUM_SQ, this);\n\n  // Deduced from http://en.wikipedia.org/wiki/Geometric_standard_deviation\n  // using wxmaxima... who knows maybe it's correct...\n  return Math.exp(\n    Math.sqrt(\n      (\n        count * Math.pow(Math.log(log_sum / count), 2) +\n        log_sum_sq -\n        2 * log_sum * Math.log(log_sum / count)\n      ) / count\n    )\n  );\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "geometricStandardDeviation",
      "string": "Histogram.prototype.geometricStandardDeviation()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "percent",
        "description": "Percentile to estimate between 1 and 100"
      }
    ],
    "description": {
      "full": "<p>Estimate the value of the <code>percent</code> percentile. The <code>percent</code> parameter must<br />be a number between <code>0</code> and <code>100</code>.</p>\n\n<p><strong>Warning</strong>, this method <strong>only estimates</strong> the requested percentile.There is<br />no way to compute the exact percentiles for histograms. This could be done<br />for simple measures, but this is <strong>not</strong> implemented in the telemetry<br />analysis backend, and it would be non-trivial to compute the exact<br />percentiles.</p>\n\n<p>The the request percentile is estimated by first finding the bucket that<br />contains the given percentile. This is pretty easy as we know how many hits<br />each bucket has. Once we know which bucket contains the requested percentile<br />then we know that the requested percentile is between the start and the end<br />of this bucket. From here we then interpolate the percentile as a point<br />between start and end of the given bucket. For <code>'linear'</code> histograms we<br />employ a linear interpolation, for <code>'exponential'</code> histograms an exponential<br />interpolation is employed.</p>\n\n<p>Please, note that for percentiles located in the highest bucket, this is<br />often the case for the 95th percentile, there is no upper-bound specified for<br />the bucket. To allow for interpolation to work when estimating the requested<br />percentile within this bucket, an upper-bound for the highest bucket is<br />estimated. See <code>Histogram.each</code> for details on how this the highest bucket<br />upper-bound is estimated.</p>\n\n<pre><code>// Print estimated percentile if available\nif (histogram.kind() == 'linear') {\n  console.log(\"Estimated median with linear interpolation:\");\n  console.log(histogram.percentile(50));\n}\nif (histogram.kind() == 'exponential') {\n  console.log(\"Estimated median with exponential interpolation:\");\n  console.log(histogram.percentile(50));\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> and<br /><code>'exponential'</code> histograms, see <code>Histogram.kind()</code> to see what kind of<br />histogram you have. Invoking this method on any other kind of histogram will<br />throw an exception.</p>",
      "summary": "<p>Estimate the value of the <code>percent</code> percentile. The <code>percent</code> parameter must<br />be a number between <code>0</code> and <code>100</code>.</p>",
      "body": "<p><strong>Warning</strong>, this method <strong>only estimates</strong> the requested percentile.There is<br />no way to compute the exact percentiles for histograms. This could be done<br />for simple measures, but this is <strong>not</strong> implemented in the telemetry<br />analysis backend, and it would be non-trivial to compute the exact<br />percentiles.</p>\n\n<p>The the request percentile is estimated by first finding the bucket that<br />contains the given percentile. This is pretty easy as we know how many hits<br />each bucket has. Once we know which bucket contains the requested percentile<br />then we know that the requested percentile is between the start and the end<br />of this bucket. From here we then interpolate the percentile as a point<br />between start and end of the given bucket. For <code>'linear'</code> histograms we<br />employ a linear interpolation, for <code>'exponential'</code> histograms an exponential<br />interpolation is employed.</p>\n\n<p>Please, note that for percentiles located in the highest bucket, this is<br />often the case for the 95th percentile, there is no upper-bound specified for<br />the bucket. To allow for interpolation to work when estimating the requested<br />percentile within this bucket, an upper-bound for the highest bucket is<br />estimated. See <code>Histogram.each</code> for details on how this the highest bucket<br />upper-bound is estimated.</p>\n\n<pre><code>// Print estimated percentile if available\nif (histogram.kind() == 'linear') {\n  console.log(\"Estimated median with linear interpolation:\");\n  console.log(histogram.percentile(50));\n}\nif (histogram.kind() == 'exponential') {\n  console.log(\"Estimated median with exponential interpolation:\");\n  console.log(histogram.percentile(50));\n}\n</code></pre>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> and<br /><code>'exponential'</code> histograms, see <code>Histogram.kind()</code> to see what kind of<br />histogram you have. Invoking this method on any other kind of histogram will<br />throw an exception.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Histogram.prototype.percentile = function Histogram_percentile(percent) {\n  if (this.kind() != \"linear\" && this.kind() != \"exponential\") {\n    throw new Error(\"Histogram.percentile() is only available for linear \" +\n                    \"and exponential histograms\");\n  }\n\n  var frac  = percent / 100;\n  var count = this.count();\n\n  // Count until we have the bucket containing the percentile\n  var to_count = count * frac;\n  var i, n = this._buckets.length;\n  for (i = 0; i < n; i++) {\n    var nb_points = _aggregate(i, this);\n    if (to_count - nb_points <= 0) {\n      break;\n    }\n    to_count -= nb_points;\n  }\n\n  // Bucket start and end\n  var start = this._buckets[i];\n  var end   = this._buckets[i+1];\n  if(i >= n - 1) {\n    // If we're at the end bucket, then there's no next bucket, hence, no upper\n    // bound, so we estimate one.\n    end = _estimateLastBucketEnd(this);\n  }\n\n  // Fraction indicating where in bucket i the percentile is located\n  var bucket_fraction = to_count / (_aggregate(i, this) + 1);\n\n  if (this.kind() == \"exponential\") {\n    // Interpolate median assuming an exponential distribution\n    return start + Math.exp(Math.log(end - start) * bucket_fraction);\n  }\n\n  // Interpolate median assuming a uniform distribution between start and end.\n  return start + (end - start) * bucket_fraction;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "percentile",
      "string": "Histogram.prototype.percentile()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Estimate the <a href=\"http://en.wikipedia.org/wiki/Median\">median</a>, also known as<br />the 50th percentile.</p>\n\n<p>This is just an alias for <code>Histogram.percentile(50)</code>, read documentation for<br /><code>Histogram.percentile</code> to understand limitations of the estimation.</p>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> and<br /><code>'exponential'</code> histograms, see <code>Histogram.kind()</code> to see what kind of<br />histogram you have. Invoking this method on any other kind of histogram will<br />throw an exception.</p>",
      "summary": "<p>Estimate the <a href=\"http://en.wikipedia.org/wiki/Median\">median</a>, also known as<br />the 50th percentile.</p>",
      "body": "<p>This is just an alias for <code>Histogram.percentile(50)</code>, read documentation for<br /><code>Histogram.percentile</code> to understand limitations of the estimation.</p>\n\n<p><strong>Remark</strong>, this method in <strong>only supported</strong> for <code>'linear'</code> and<br /><code>'exponential'</code> histograms, see <code>Histogram.kind()</code> to see what kind of<br />histogram you have. Invoking this method on any other kind of histogram will<br />throw an exception.</p>"
    },
    "ignore": false,
    "code": "Histogram.prototype.median = function Histogram_median() {\n  return this.percentile(50);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "median",
      "string": "Histogram.prototype.median()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Callback to be invoked with buckets"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "ctx",
        "description": "Optional, context for the callback"
      }
    ],
    "description": {
      "full": "<p>Iterate over buckets, ordered from low to high, by having <code>cb</code> invoked as<br /><code>cb(count, start, end, index)</code> for each bucket in this <code>Histogram</code> instance.</p>\n\n<p>In the <code>cb(count, start, end, index)</code> invocation of <code>cb</code>, <code>count</code> the number<br />of measurements that fell in the interval between <code>start</code> and <code>end</code>, while<br /><code>index</code> is the bucket index, an integer incremented by one for each<br />invocation of <code>cb</code>.</p>\n\n<p>The following example shows how to print the contents of all buckets in an<br />instance of <code>Telemetry.Histogram</code>.</p>\n\n<pre><code>// Print the contents of all buckets\nhistogram.each(function(count, start, end, index) {\n  console.log(\"In bucket \" + index + \" we have \" + count + \" hits);\n  console.log(\"between \" + start + \" and \" + end);\n});\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>Histogram</code> instance as context.</p>",
      "summary": "<p>Iterate over buckets, ordered from low to high, by having <code>cb</code> invoked as<br /><code>cb(count, start, end, index)</code> for each bucket in this <code>Histogram</code> instance.</p>",
      "body": "<p>In the <code>cb(count, start, end, index)</code> invocation of <code>cb</code>, <code>count</code> the number<br />of measurements that fell in the interval between <code>start</code> and <code>end</code>, while<br /><code>index</code> is the bucket index, an integer incremented by one for each<br />invocation of <code>cb</code>.</p>\n\n<p>The following example shows how to print the contents of all buckets in an<br />instance of <code>Telemetry.Histogram</code>.</p>\n\n<pre><code>// Print the contents of all buckets\nhistogram.each(function(count, start, end, index) {\n  console.log(\"In bucket \" + index + \" we have \" + count + \" hits);\n  console.log(\"between \" + start + \" and \" + end);\n});\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>Histogram</code> instance as context.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Histogram.prototype.each = function Histogram_each(cb, ctx) {\n  // Set ctx if none is provided\n  if (ctx === undefined) {\n    ctx = this;\n  }\n\n  // For each bucket\n  var n = this._buckets.length;\n  for(var i = 0; i < n; i++) {\n\n    // Find count, start and end of bucket\n    var count = _aggregate(i, this),\n        start = this._buckets[i],\n        end   = this._buckets[i+1];\n\n    // If we're at the last bucket, then there's no next upper bound so we\n    // estimate one\n    if (i >= n - 1) {\n      end = _estimateLastBucketEnd(this);\n    }\n\n    // Invoke callback as promised\n    cb.call(ctx, count, start, end, i);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "each",
      "string": "Histogram.prototype.each()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "Mapping to be invoked with buckets"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "ctx",
        "description": "Optional, context for the callback"
      }
    ],
    "description": {
      "full": "<p>Map buckets in this <code>Histogram</code> instance to an array (ordered by buckets,<br />low to high). Bascially, <code>cb</code> is invoked as <code>cb(count, start, end, index)</code><br />for each bucket in order from low to high, then the values returned by <code>cb</code><br />is appended to an array, which is then returned by <code>map()</code>.</p>\n\n<p>This is quite similar to what <code>Histogram.each()</code> does, except the return<br />values from <code>cb</code> are stored in an array, returned by <code>map()</code> when it<br />it finished. As the following example shows how to generate a CSV dump from<br />an instance of <code>Histogram</code>.</p>\n\n<pre><code>// Print Comma-Separate-Value file from histogram\nvar csv = \"count,start,end,index\\n\";\ncsv += histogram.map(function(count, start, end, index) {\n  return [count, start, end, index].join(\",\");\n}).join(\"\\n\");\nconsole.log(csv);\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>Histogram</code> instance as context.</p>",
      "summary": "<p>Map buckets in this <code>Histogram</code> instance to an array (ordered by buckets,<br />low to high). Bascially, <code>cb</code> is invoked as <code>cb(count, start, end, index)</code><br />for each bucket in order from low to high, then the values returned by <code>cb</code><br />is appended to an array, which is then returned by <code>map()</code>.</p>",
      "body": "<p>This is quite similar to what <code>Histogram.each()</code> does, except the return<br />values from <code>cb</code> are stored in an array, returned by <code>map()</code> when it<br />it finished. As the following example shows how to generate a CSV dump from<br />an instance of <code>Histogram</code>.</p>\n\n<pre><code>// Print Comma-Separate-Value file from histogram\nvar csv = \"count,start,end,index\\n\";\ncsv += histogram.map(function(count, start, end, index) {\n  return [count, start, end, index].join(\",\");\n}).join(\"\\n\");\nconsole.log(csv);\n</code></pre>\n\n<p><strong>Remark</strong> this optional <code>ctx</code> parameter can be used to provide a context<br /><code>cb</code> should invoked within. If <code>ctx</code> is provided <code>cb</code> will invoked with the<br /><code>Histogram</code> instance as context.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Histogram.prototype.map = function Histogram_map(cb, ctx) {\n  // Set ctx if none is provided\n  if (ctx === undefined) {\n    ctx = this;\n  }\n\n  // Array of return values\n  var results = [];\n\n  // For each, invoke cb and push the result\n  this.each(function(count, start, end, index) {\n    results.push(cb.call(ctx, count, start, end, index));\n  });\n\n  // Return values from cb\n  return results;\n};\n\nreturn Histogram;\n\n})();\n\nexports.Telemetry = Telemetry;\nreturn exports.Telemetry;\n\n})(this);",
    "ctx": {
      "type": "method",
      "constructor": "Histogram",
      "cons": "Histogram",
      "name": "map",
      "string": "Histogram.prototype.map()"
    }
  }
]